
* Script
https://stackoverflow.com/questions/2482348/run-c-or-c-file-as-a-script
#+BEGIN_SRC c
  //usr/bin/env gcc -Wall -std=c99 -o $HOME/.cache/gcc/hello-world "$0" && exec $HOME/.cache/gcc/hello-world "$@"
  #include <stdio.h>

  int main ()
  {
    printf ("Hello World\n");
    return 0;
  }
#+END_SRC
http://drandom.blogspot.com/2013/12/shebang-for-c-programs.html

[[https://github.com/alcover/runc][alcover/runc: compile and run C code]]

Alternative way use [[https://bellard.org/tcc/][tcc]]
: #!/usr/bin/tcc -run

[[https://github.com/onqtam/rcrl][rcrl]]

* Concurency

- [[https://libcsp.com/][| Libcsp]]

* REPL

: docker build -t bic https://github.com/hexagonal-sun/bic.git#master
: docker run --rm -it bic:latest

* URLS

- [[https://github.com/topics][Topics on GitHub]]
- [[https://github.com/clibs/clib][clibs/clib: C package manager-ish]]
- [[https://github.com/TheAlgorithms/C][C]]
- [[https://github.com/ryanmjacobs/c][ryanmjacobs/c: Compile and execute C "scripts" in one go!]]
- [[https://github.com/fragglet/c-algorithms][fragglet/c-algorithms: A library of common data structures and algorithms written in C.]]
- [[https://github.com/dvorka/hstr/blob/master/CONFIGURATION.md][hstr/CONFIGURATION.md at master Â· dvorka/hstr]]
- [[https://github.com/rby90/Project-Based-Tutorials-in-C][rby90/Project-Based-Tutorials-in-C: A curated list of project-based tutorials in C]]

* Heap
 - large pool of operating system memory
 - used in dynamic memory allocation

** Allocate memory on the heap
 - the ~new~ keyword in C++
 - the ~malloc~ in C

 : int * myArray = new int 10;

* Stack
 - each process gets its own stack (assume single-threaded processes)
 - LIFO, like the data structure
 - contiguos block of memory (the process's address space)

** Stack frames
 - the stack consists of stack frames
 - contains the parameters to a function, its local variables, and the
   data necessary to recover the previous stack frame
 - when a function is called, a frame for that function is *pushed*
   onto the stack
 - when the function is done, we pop the stack frame and return to the
   caller
 - contains *high-performance* memory
 - usually *fixed* limits
 - to clarify :: stack memory is high-performance in terms of
		 ALLOCATION time, not ACCESS time

 : int myArray[10];

* Chip architecture and assembly language review
** What is assembly
 - assembly = machine instructions
 - C is higher level language which gets translated into assembly by
   the compiler
 - key point :: assembly language tells the computer exactly what to do
		and exactly HOW to do it
 - C or C++ :: will say "allocate memory" or "perform addition" ~x += 1;~
 - Assembly :: will say "put the byte from this address in memory into
	       ~MOV EAX, x~ ~ADD EAX, 1~ this register" or "jump to
	       this location in memory"

** Registers
- definition :: extremely high-performance memory located directly on
		the chip

*** General purpose registers
 - EAX, EBX, ECX, EDX
 - Used for performing operations on data

*** Special purpose registers
 - ESP: Stack pointer, points to the top of the stack. Manipulated by
   PUSH, POP, etc
 - EBP: Base pointer aka frame pointer.
 - ESI and EDI: ESI = source instruction, EDI = destination instruction.

* Assembly language calls
** Can be of the form [opcode][dest], [source]
Moves the value "1" into the EAX register
 : MOV EAX, 1

** Can be of the form [opcode][operand]
 - jumps to and address in memory
 - in this case the hex address is 0xDEADBEEF

 : JMP 0xDEADBEEF

** Stack-related mneumonic
 - PUSH [register]
 - POP [register]
 - CALL [function]
 - RET
* Compile and run
 : echo '_Bool a;' | gcc -c -x c -
 : echo $?

* Debug

- Compile flags
  : -g3 -O0

* Unicode

Сам по себе не является форматом записи символов в компьютер.

Это всего лишь какой-то формат,
как можно в принципе записать большое количество символов.

Тут нету такой вещи как кодировка или еще что-то.

Это огромный список, который состоит из двух коллекций:
- базовая (bone);
- расширенная.

Расширенная коллекция подразделяется на подчасти.

** Принципы работы

В unicode можно записать символы разными способами.

Лучший пример это буква "ё" в русском алфавите.

Букву "ё" можно записать двумя способами:
- сам символ "ё";
- символ "е" и добавочный символ "две верхние точки".

Символ "две верхние точки" не имеет ширины.

Еще раз прошу заметить, что сейчас мы говорим не о записи символов в компьютер.

Unicode - это коллекция символов.

** Как разбиваются символы в unicode?


* UCS

UCS (Universal Character Set) - это универсальный набор символов.

Здесь мы уже начинаем говорить о конкретном коде.

В компьютере мы как правило работаем с какой-то кодировкой.

UCS - это одна из кодировок.

UCS берет последственный номер внутри Unicode и
фактически забивает его в память компьютера.

У нас получается самый прямой результат.

Если мы берем Unicode и
просто один в один связываем его с байтами в памяти компьютера,
то мы получим UCS.

Из-за этого есть *две разновидности UCS*:
- UCS-1
- UCS-2

UCS-1 использует один восьмибитный байт.
UCS-2 использует два восьмибитных байта, то есть шестнадцать бит.

Из-за этого некоторый люди ошибочно называют UCS-2 как /UCS-16/.

UCS - это кодировка, которая использует конкретное количество байт.

То есть если у нас UCS-1 использует 1 байт, то UCS-1 всегда использует 1 байт.

Из-за использования двух байт в UCS,
вы можете целиком выразить,
так называемые понятия BMP (с картинками не имеет не чего общего).

BMP - базовая карта символов,
которая позволяет вам выразить почти все символы,
которые вам могут понадобится.

2 байта около 65 000 символов

Проблема в том, что например в Китае не могут продаваться программы,
которые не поддерживают кодировку /GB 18030/.

GB 18030 уже выходит за рамки BMP и UCS-2.

Поэтому нам либо нужно идти использовать 32 бита,
что в принципе возможно (можно использовать 32 бита с помощью UCS).

Либо мы идем и начинаем работать с UTF.

* UTF

UTF от UCS отличается тем,
что вы можете использовать разное количество ваших слов,
для выражения какого-то символа.

То есть если в UCS-1 у нас слово это один байт,
если в UCS-2 у нас слово это два байта,
то в UTF у нас количество байт в слове всегда одинаковое,
но количество слов в символе будет разное.

UTF (UCS Transfer format) - это формат передачи UCS.

Это более логичный подход к тому,
что мы можем взять то что делает UCS,
и передать эти данные через какой-то канал связи.

Поэтому UTF-8 - это один из самых популярных форматов.

Он весьма популярный, потому что хорошо работает с теми файлами,
которые почти полностью находятся внутри,
так называемой более старой кодировки ASCII.

ASCII - это кодировка, которая использовалась почти на всех старых компьютерах.

Первоначально ASCII использовала 7 бит.

То есть в восьмибитном байте, первый бит ставился нулю,
и потом мы использовали 7 бит.

| 0 | _ | _ | _ | _ | _ | _ | _ |   |
| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | A |
|   |   |   |   |   |   | 1 | 0 | B |
|   |   |   |   |   |   | 1 | 1 | C |
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   | Z |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | a |

Все латинские буквы,
вся пунктуация,
у нее будет в одном байте первый бит равен нулю.

Поэтому, если мы используем 8 бит в UTF-8,
то мы можем закодировать это следующим образом.

Если у нас в UTF-8 первый бит равен нулю (оставляем это как в таблице ASCII).

Поэтому если у вас есть текстовый документ в формате ASCII,
и вы хотите передать его через интернет,
то совершенно спокойно можете это сделать.

Дальше ASCII начало развиваться,
начало добавлять вещи.

Например символы из TUI интерфейса (различные уголки и тому подобное).

Все эти символы были забиты с первым битом равном единице.

- Windows 12...
- Koi
- Koi-U (украинская)
- для DOS
- для IBM
  
Если вы пытаетесь передать документ в другую страну,
люди даже понятия не имеют,
что такие кодировки существуют.

У них точно не будет программ,
которые могут это читать.

Первоначально проблем не было,
так как люди печатали документы на принтерах,
и отсылали по факсу.

Сегодня такого делать не кто не будет.

Сегодня люди хотят прислать "документ как он есть" через интернет.

$$2^{7}$$ символов, тоже что и в нижней части ASCII.

| 0 | _ | _ | _ | _ | _ | _ | _ |

$$2{13}$$

| 1 | 1 | 0 | _ | _ | _ | _ | _ |

| 1 | 0 | _ | _ | _ | _ | _ | _ |

Первая единица означает, что у нас будет символ,
который выходит за рамки одного байта.

Вот эти "шапки":

| 1 | 1 | 0 |

| 1 | 0 |

означают что мы можем использовать 11 бит.

Теперь мы закодировали $2{7} + 2{13}$.

| 1 | 1 | 1 | 0 | _ | _ | _ | _ |
| 1 | 0 | _ | _ | _ | _ | _ | _ |
| 1 | 0 | _ | _ | _ | _ | _ | _ |

$2{16}$ после $2{7}$ после $2{13}$.

*ASCII само корриктирующийся.*

К примеру мы сбились
и не знаем где находимся в процессе раскодирования нашего символа.

Мы видим какой-то байт перед нами.
 
Мы видим, что этот байт начинается с 1 и 0.

Рас мы сбились, то у нас есть два подхода либо:
- откатываем обратно и пытаемся восстановить;
- нам не нужно восстанавливаться, нам нужно просто раскодировать дальше.

Во втором случае не пытаться раскодировать то, что уже потеряли.

Либо мы ищем байт который начинается с нуля,
либо который начинается с двух единиц.

Здесь есть проблемы, например у вас используется несколько байт,
для кодировки русских символов.

То есть в кодировке например KOI вы используете один байт для символа,
а UTF-8 как правило для байта.

* UTF-16




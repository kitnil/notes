- [[https://github.com/sahib/rmlint][sahib/rmlint: Extremely fast tool to remove duplicates and other lint from your filesystem]]
- [[https://github.com/trapexit/mergerfs][trapexit/mergerfs: a featureful union filesystem]]
- [[https://github.com/cunctator/traceshark][cunctator/traceshark: This is a tool for Linux kernel ftrace and perf events visualization]]
- [[https://github.com/aide/aide][aide/aide: aide source code]]
- [[https://github.com/apjanke/ronn-ng][apjanke/ronn-ng: Ronn-NG: An updated fork of ronn. Build man pages from Markdown.]]
- [[https://github.com/acaudwell/Logstalgia][acaudwell/Logstalgia: replay or stream website access logs as a retro arcade game]]
- [[https://github.com/gregkh/usbview][gregkh/usbview: usb viewer for Linux]]
- [[https://github.com/nelhage/reptyr][nelhage/reptyr: Reparent a running program to a new terminal]]
- [[https://github.com/Xfennec/progress][Xfennec/progress: Linux tool to show progress for cp, mv, dd, ... (formerly known as cv)]]
- [[https://github.com/pshved/timeout][pshved/timeout: A script to measure and limit CPU time and memory consumption of black-box processes in Linux]]
- [[https://github.com/brendangregg/FlameGraph][brendangregg/FlameGraph: Stack trace visualizer]]
- [[https://github.com/iberianpig/xSwipe][iberianpig/xSwipe: Multitouch gestures with synaptics driver on X11, Linux]]
- [[https://github.com/lukeed/watchlist][lukeed / watchlist JavaScript]]
- [[https://github.com/bannsec/linux-kernel-lab][bannsec/linux-kernel-lab: Lab Environment For Learning About The Linux Kernel]]
- [[https://habr.com/ru/post/503648/][Что обозначает вывод «ss -s» / Хабр]]
- [[https://www.rodsbooks.com/gdisk/wipegpt.html][Wiping Out Old GPT Data]]
- [[https://github.com/leandromoreira/linux-network-performance-parameters][leandromoreira/linux-network-performance-parameters: Learn where some of the network sysctl variables fit into the Linux/Kernel network flow]]
- [[https://blog.tinned-software.net/modify-file-and-directory-date/][Modify file and directory date - Experiencing Technology]]
- [[https://loicpefferkorn.net/2016/03/linux-network-metrics-why-you-should-use-nstat-instead-of-netstat/][Linux network metrics: why you should use nstat instead of netstat]]
- [[https://github.com/asz/icmpshell][asz/icmpshell: Experimental kernel-level remote shell based on ICMP content]]
- [[https://github.com/sp00f1ng/booty][sp00f1ng/booty: Boot to any GNU/Linux via PXE, ISO or USB, HDD, SSD and so on... With using the shmfs (tmpfs) or Overlay FS + SquashFS.]]
- [[https://github.com/foundObjects/zram-swap][foundObjects/zram-swap: A simple zram swap service for modern systemd Linux]]
- [[https://github.com/jarun/keysniffer][jarun/keysniffer: Linux kernel mode debugfs keylogger]]
- [[https://github.com/jarun/bcal][jarun/bcal: :1234: Storage and regular CLI calculator]]

* Containers
- [[https://github.com/genuinetools/amicontained][genuinetools/amicontained: Container introspection tool. Find out what container runtime is being used as well as features available.]]

* ALSA
- [[https://rendaw.gitlab.io/blog/2125f09a85f2.html#alsa-exposed][rendaw - ALSA, exposed!]]

* IO
- [[https://github.com/osresearch/iomonitor][osresearch/iomonitor: Trace IO calls in a process]]

* BPF
- [[https://www.geeklan.co.uk/?p=2493][Book review: BPF Performance Tools: Linux System and Application Observability – GeekLAN]]
- [[https://github.com/iovisor/bpftrace][iovisor/bpftrace: High-level tracing language for Linux eBPF]]

* Lockdown
- [[https://github.com/x08d/lockdown.sh][x08d/lockdown.sh: Lockdown your linux install. The simple zero config linux hardening script]]

* Documentation

- [[https://github.com/filiparag/wikiman][filiparag/wikiman: Wikiman is an offline search engine for manual pages, Arch Wiki, Gentoo Wiki and other documentation.]]
- [[https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf][rh_ip_command_cheatsheet_1214_jcs_print.pdf]]
- [[https://habr.com/en/post/416669/][Вся правда о linux epoll / Habr]]
  - [[http://artemy-kolesnikov.blogspot.com/2010/11/epoll.html][Программерский блог: Использование epoll]]
  - [[https://www.insight-it.ru/linux/2012/kak-rabotaet-epoll/][Как работает epoll?]]
- [[https://www.kernel.org/doc/html/latest/admin-guide/index.html][The Linux kernel user’s and administrator’s guide — The Linux Kernel documentation]]

- [[https://archlinux.org.ru/forum/topic/19282/][Анализ зависшего процесса]]
- [[https://github.com/0xAX/linux-insides][0xAX/linux-insides: A little bit about a linux kernel]]

* News
- Lxer :: http://lxer.com/
- Linux Today :: https://www.linuxtoday.com/
- Slash dot :: https://linux.slashdot.org/
- Alltop :: https://alltop.com/linux
- TuxURLs :: https://tuxurls.com/
- Hackernews :: https://news.ycombinator.com/

* Video

- [[https://www.youtube.com/playlist?list=PLypxmOPCOkHXbJhUgjRaV2pD9MJkIArhg][C Programming in Linux Tutorial - YouTube]]

* Shebang

- [[https://www.in-ulm.de/~mascheck/various/shebang/#splitting][The #! magic, details about the shebang/hash-bang mechanism]]
  - fs/binfmt_script.c
  - [[https://web.archive.org/web/20150923090050/http://lkml.org/lkml/2004/2/16/74][LKML: Hansjoerg Lipp: [PATCH] Linux 2.6: shebang handling in fs/binfmt_script.c]]
  - [[https://linux.die.net/man/2/execve][execve(2): execute program - Linux man page]]

* nice and ionice

- [[https://www.tiger-computing.co.uk/linux-tips-nice-and-ionice/][Linux Tips: nice and ionice - Tiger Computing]]

Most system administrators understand the nice command, which may be
used to change a process’s priority. Any user can change the priority
of processes running under their UID, but only root may change others’
processes.

The current nice value of a process can be shown in a variety of ways,
with perhaps the simplest being to use top where the nice value is
shown in the column labelled NI. We can also see the nice value with
some forms of the ps command; for example, here we see the PID, the
nice value and the command:

#+BEGIN_SRC bash
  ps -o pid,ni,comm 
#+END_SRC

#+RESULTS:
:   PID  NI COMMAND 
:  1477   0 bash 
: 18710   0 ps

Perhaps confusingly, the lower the nice value the higher the
priority. For most processes, the default nice value is zero. There
are two versions of the command: nice (to start a process with a
specific nice value), and renice (to alter the nice value of a running
process). If your complex calculation running as PID 12345 is taking a
lot of processing power, you can be a good server citizen by reducing
its priority using renice:

#+BEGIN_SRC bash
  renice 10 12345
#+END_SRC
#+RESULTS:
: 12345 (process ID) old priority 0, new priority 10

Or maybe your calculation is more important than everyone else’s work:

#+BEGIN_SRC bash
  renice -10 12345
#+END_SRC

#+RESULTS:
: renice: failed to set priority for 12345 (process ID): Permission denied

– but you’ll need to be root to do that.
ionice

Not so well understood is the ionice command, which sets or shows both
the I/O class and, within that class, the priority. There are four
classes:

0) None
1) Realtime
2) Best-effort
3) Idle

Confusingly, on a modern kernel, “None” and “Best-effort” are the same
thing, and they are also the default. The Idle class does as you might
expect: it executes I/O for the process in question when there is no
other I/O scheduled, and, as such, it does not take a priority.

Both “Realtime” and “Best-effort” take a priority level from zero to
7, with zero having the highest priority. “Realtime” tries to give
processes immediate access to the disk, ordered by priority.  Examples

Here we examine the class and priority used by PID 3467:

#+BEGIN_SRC bash
  ionice -p 3467
#+END_SRC

#+RESULTS:
: best-effort: prio 4

If we are root, we could switch that to the Realtime class with a
priority of 3:

#+BEGIN_SRC bash
  ionice -c 1 -n 3 -p 3467 
  ionice  -p 3467
#+END_SRC

#+RESULTS:
: realtime: prio 3

Application

So when might you use this? Maybe you have some rsync processes
running on a production server, and they’re impacting performance. You
don’t want to abort them, but you do want to reduce their impact, so
you set the I/O scheduling class to Idle. The rsyncs will take longer,
possibly a lot longer, but they will no longer cause a performance
degradation:

#+BEGIN_SRC bash
  for pid in $(pidof rsync); do ionice -c 3 -p $pid; done
#+END_SRC

* Memory

[[https://github.com/0x0f0f0f/memplot][0x0f0f0f/memplot: Generate image plots of processes' memory usage very quickly, within a single binary.]]

* Networking

oleg@guixsd ~$ ss --numeric --tcp --listening --no-header --oneline --processes '( sport = :5901 )'

* source

/home/oleg/archive/src/linux/arch/x86/entry/syscalls/syscall_64.tbl

* console
#+begin_quote
I think it would also be nice if the sysadmins could get
access to the serial console (or even the racadm console).  With the
serial console you could see if the server is stuck even if you can’t
SSH.  With the racadm console (where we type “console com2” to start the
serial console) you could also trigger a soft reboot.

We have these management interfaces pretty locked down, but perhaps we
can set up a tunnel from bayfront, or something like that.
#+end_quote

* scsi
- [[https://serverfault.com/questions/5336/how-do-i-make-linux-recognize-a-new-sata-dev-sda-drive-i-hot-swapped-in-without][How do I make Linux recognize a new SATA /dev/sda drive I hot swapped in without rebooting? - Server Fault]]
- [[https://github.com/koct9i/ioping][koct9i/ioping: simple disk I/0 latency measuring tool]]
- fio --name=randwrite --rw=randwrite --direct=1 --ioengine=libaio --bs=64k --numjobs=8 --size=512m --runtime=600 --group_reporting
** Utilities
- ioping
- fio

* reboot

** proc

$ sudo echo 1 > /proc/sys/kernel/sysrq

To reboot, you can use either Alt+Sysrq+B or type:

$ sudo echo b > /proc/sysrq-trigger

This method is not a reasonable way to reboot your machine on a regular basis, but it gets the job done in a pinch.

** sysctl

sysctl --all
sysctl --value kernel.panic

If you get a 0 back, then the kernel you’re running has no special setting, at
least by default, to reboot upon a kernel panic. That situation is fairly
typical since rebooting immediately on a catastrophic system crash makes it
difficult to diagnose the cause of the crash. Then again, systems that need to
stay on no matter what might benefit from an automatic restart after a kernel
failure, so it’s an option that does get switched on in some cases.

You can activate this feature as an experiment (if you’re following along, try
this in a virtual machine rather than on your actual computer):

$ sudo sysctl kernel.reboot=1

Now, should your computer experience a kernel panic, it is set to reboot
instead of waiting patiently for you to diagnose the problem. You can test
this by simulating a catastrophic crash with sysrq. First, make sure that
Sysrq is enabled:

$ sudo echo 1 > /proc/sys/kernel/sysrq

And then simulate a kernel panic:

$ sudo echo c > /proc/sysrq-trigger

Your computer reboots immediately.

* BCC
https://github.com/iovisor/bcc/blob/master/QUICKSTART.md

* udev
: udevadm info --attribute-walk --query-all --path=/class/block/sda1 | grep mysql

* nftables
- [[https://github.com/google/nftables][google/nftables: This package manipulates Linux nftables (the iptables successor)]]

* Build
- [[https://github.com/takano32/build-kernel][takano32/build-kernel]]

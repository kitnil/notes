- [[https://github.com/iberianpig/xSwipe][iberianpig/xSwipe: Multitouch gestures with synaptics driver on X11, Linux]]
- [[https://github.com/lukeed/watchlist][lukeed / watchlist JavaScript]]
- [[https://github.com/bannsec/linux-kernel-lab][bannsec/linux-kernel-lab: Lab Environment For Learning About The Linux Kernel]]
- [[https://habr.com/ru/post/503648/][Что обозначает вывод «ss -s» / Хабр]]
- [[https://www.rodsbooks.com/gdisk/wipegpt.html][Wiping Out Old GPT Data]]
- [[https://github.com/leandromoreira/linux-network-performance-parameters][leandromoreira/linux-network-performance-parameters: Learn where some of the network sysctl variables fit into the Linux/Kernel network flow]]
- [[https://blog.tinned-software.net/modify-file-and-directory-date/][Modify file and directory date - Experiencing Technology]]
- [[https://loicpefferkorn.net/2016/03/linux-network-metrics-why-you-should-use-nstat-instead-of-netstat/][Linux network metrics: why you should use nstat instead of netstat]]

* Documentation

- [[https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf][rh_ip_command_cheatsheet_1214_jcs_print.pdf]]
- [[https://habr.com/en/post/416669/][Вся правда о linux epoll / Habr]]
  - [[http://artemy-kolesnikov.blogspot.com/2010/11/epoll.html][Программерский блог: Использование epoll]]
  - [[https://www.insight-it.ru/linux/2012/kak-rabotaet-epoll/][Как работает epoll?]]
- [[https://www.kernel.org/doc/html/latest/admin-guide/index.html][The Linux kernel user’s and administrator’s guide — The Linux Kernel documentation]]

* Video

- [[https://www.youtube.com/playlist?list=PLypxmOPCOkHXbJhUgjRaV2pD9MJkIArhg][C Programming in Linux Tutorial - YouTube]]

* Shebang

- [[https://www.in-ulm.de/~mascheck/various/shebang/#splitting][The #! magic, details about the shebang/hash-bang mechanism]]
  - fs/binfmt_script.c
  - [[https://web.archive.org/web/20150923090050/http://lkml.org/lkml/2004/2/16/74][LKML: Hansjoerg Lipp: [PATCH] Linux 2.6: shebang handling in fs/binfmt_script.c]]
  - [[https://linux.die.net/man/2/execve][execve(2): execute program - Linux man page]]

* nice and ionice

- [[https://www.tiger-computing.co.uk/linux-tips-nice-and-ionice/][Linux Tips: nice and ionice - Tiger Computing]]

Most system administrators understand the nice command, which may be
used to change a process’s priority. Any user can change the priority
of processes running under their UID, but only root may change others’
processes.

The current nice value of a process can be shown in a variety of ways,
with perhaps the simplest being to use top where the nice value is
shown in the column labelled NI. We can also see the nice value with
some forms of the ps command; for example, here we see the PID, the
nice value and the command:

#+BEGIN_SRC bash
  ps -o pid,ni,comm 
#+END_SRC

#+RESULTS:
:   PID  NI COMMAND 
:  1477   0 bash 
: 18710   0 ps

Perhaps confusingly, the lower the nice value the higher the
priority. For most processes, the default nice value is zero. There
are two versions of the command: nice (to start a process with a
specific nice value), and renice (to alter the nice value of a running
process). If your complex calculation running as PID 12345 is taking a
lot of processing power, you can be a good server citizen by reducing
its priority using renice:

#+BEGIN_SRC bash
  renice 10 12345
#+END_SRC
#+RESULTS:
: 12345 (process ID) old priority 0, new priority 10

Or maybe your calculation is more important than everyone else’s work:

#+BEGIN_SRC bash
  renice -10 12345
#+END_SRC

#+RESULTS:
: renice: failed to set priority for 12345 (process ID): Permission denied

– but you’ll need to be root to do that.
ionice

Not so well understood is the ionice command, which sets or shows both
the I/O class and, within that class, the priority. There are four
classes:

0) None
1) Realtime
2) Best-effort
3) Idle

Confusingly, on a modern kernel, “None” and “Best-effort” are the same
thing, and they are also the default. The Idle class does as you might
expect: it executes I/O for the process in question when there is no
other I/O scheduled, and, as such, it does not take a priority.

Both “Realtime” and “Best-effort” take a priority level from zero to
7, with zero having the highest priority. “Realtime” tries to give
processes immediate access to the disk, ordered by priority.  Examples

Here we examine the class and priority used by PID 3467:

#+BEGIN_SRC bash
  ionice -p 3467
#+END_SRC

#+RESULTS:
: best-effort: prio 4

If we are root, we could switch that to the Realtime class with a
priority of 3:

#+BEGIN_SRC bash
  ionice -c 1 -n 3 -p 3467 
  ionice  -p 3467
#+END_SRC

#+RESULTS:
: realtime: prio 3

Application

So when might you use this? Maybe you have some rsync processes
running on a production server, and they’re impacting performance. You
don’t want to abort them, but you do want to reduce their impact, so
you set the I/O scheduling class to Idle. The rsyncs will take longer,
possibly a lot longer, but they will no longer cause a performance
degradation:

#+BEGIN_SRC bash
  for pid in $(pidof rsync); do ionice -c 3 -p $pid; done
#+END_SRC

* Memory

[[https://github.com/0x0f0f0f/memplot][0x0f0f0f/memplot: Generate image plots of processes' memory usage very quickly, within a single binary.]]

* Networking

oleg@guixsd ~$ ss --numeric --tcp --listening --no-header --oneline --processes '( sport = :5901 )'

* source

/home/oleg/archive/src/linux/arch/x86/entry/syscalls/syscall_64.tbl

* reboot

** proc

$ sudo echo 1 > /proc/sys/kernel/sysrq

To reboot, you can use either Alt+Sysrq+B or type:

$ sudo echo b > /proc/sysrq-trigger

This method is not a reasonable way to reboot your machine on a regular basis, but it gets the job done in a pinch.

** sysctl

sysctl --all
sysctl --value kernel.panic

If you get a 0 back, then the kernel you’re running has no special setting, at
least by default, to reboot upon a kernel panic. That situation is fairly
typical since rebooting immediately on a catastrophic system crash makes it
difficult to diagnose the cause of the crash. Then again, systems that need to
stay on no matter what might benefit from an automatic restart after a kernel
failure, so it’s an option that does get switched on in some cases.

You can activate this feature as an experiment (if you’re following along, try
this in a virtual machine rather than on your actual computer):

$ sudo sysctl kernel.reboot=1

Now, should your computer experience a kernel panic, it is set to reboot
instead of waiting patiently for you to diagnose the problem. You can test
this by simulating a catastrophic crash with sysrq. First, make sure that
Sysrq is enabled:

$ sudo echo 1 > /proc/sys/kernel/sysrq

And then simulate a kernel panic:

$ sudo echo c > /proc/sysrq-trigger

Your computer reboots immediately.

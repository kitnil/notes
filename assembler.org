#+title: Assembler

- [[https://www.youtube.com/c/CryptFunIT/playlists?view=1&sort=dd&shelf_id=0][(97) CryptoFun [ IT ] - YouTube]]
- [[https://www.youtube.com/c/BenEater/featured][(97) Ben Eater - YouTube]]
- [[https://developer.amd.com/resources/developer-guides-manuals/][Developer Guides, Manuals & ISA Documents - AMD]]
- [[https://github.com/cch123/asm-cli-rust][cch123/asm-cli-rust: interative assembly shell written in rust]]
- [[https://github.com/cch123/asm-cli][cch123/asm-cli: Interactive shell of assembly language(X86/X64) based on unicorn and keystone]]
- [[https://www.agner.org/optimize/#manuals][Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X]]

[[https://habr.com/ru/post/569204/#comment_23288698]]
Обычно ассемблер является отображением машинных кодов практически 1 в 1. Мы,
например, на 1 курсе университета писали программы в машинных кодах в
debug.exe, чтобы потом вздохнуть с облегчением, когда начался ассемблер. Да
транслятор вычисляет размеры операндов и адреса меток за вас, но в остальном
не сказал бы, что есть какая-то существенная разница. Зная ассемблер,
например, вы можете в отладчике остановиться на вызове функции отображения
месседжбокса ("This program is not licensed"), промотать код немножко вверх и
заменить jne на je (например, обычно конечно всё сложнее) - и вот уже
программа принимает любой ключ, кроме собственно верного. Затем, зная, где
находится это место в коде - открываете какой-нибудь HIEW и патчите опкод
перехода руками. Просматривая голые hex-коды сделать то же самое будет гораздо
сложнее.

:PROPERTIES:
:ID:       bb14685f-f6d2-460e-b2d5-a8c964fa4752
:END:
#+title: Assembler

- [[https://github.com/nanochess][nanochess (Oscar Toledo)]]
- [[https://github.com/Blackend/Cyjon][Blackend/Cyjon: A simple, clean code, multi-tasking operating system written in pure assembly language for 64-bit processors from the AMD64 family.]]
- [[https://www.youtube.com/c/CryptFunIT/playlists?view=1&sort=dd&shelf_id=0][(97) CryptoFun [ IT ] - YouTube]]
- [[https://www.youtube.com/c/BenEater/featured][(97) Ben Eater - YouTube]]
- [[https://developer.amd.com/resources/developer-guides-manuals/][Developer Guides, Manuals & ISA Documents - AMD]]
- [[https://github.com/cch123/asm-cli-rust][cch123/asm-cli-rust: interative assembly shell written in rust]]
- [[https://github.com/cch123/asm-cli][cch123/asm-cli: Interactive shell of assembly language(X86/X64) based on unicorn and keystone]]
- [[https://www.agner.org/optimize/#manuals][Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X]]
- [[https://github.com/tenderlove/asmrepl][tenderlove/asmrepl: A REPL for x86-64 assembly language]]
- [[https://github.com/icebreaker/floppybird][icebreaker/floppybird: Floppy Bird (OS)]]
- [[https://github.com/nanochess/Invaders][nanochess/Invaders: Invaders game in 512 bytes (boot sector)]]
- [[https://github.com/io12/BootMine][io12/BootMine: Bootable minesweeper game in a 512-byte boot sector]]
- [[https://github.com/mat-sz/bfloader][mat-sz/bfloader: Brainfuck IDE and interpreter in 512 bytes. (boot sector)]]
- [[https://github.com/Dman95/SASM][Dman95/SASM: SASM - simple crossplatform IDE for NASM, MASM, GAS and FASM assembly languages]]
- [[https://github.com/icedland/iced][icedland/iced: Blazing fast and correct x86/x64 disassembler, assembler, decoder, encoder for .NET, Rust, Python, JavaScript]]
- [[https://github.com/x64dbg/x64dbg][x64dbg/x64dbg: An open-source x64/x32 debugger for windows.]]
- [[https://github.com/ThomasJaeger/VisualMASM][ThomasJaeger/VisualMASM: Visual MASM - Assembly IDE for Microsoft MASM]]

[[https://habr.com/ru/post/569204/#comment_23288698]]
Обычно ассемблер является отображением машинных кодов практически 1 в 1. Мы,
например, на 1 курсе университета писали программы в машинных кодах в
debug.exe, чтобы потом вздохнуть с облегчением, когда начался ассемблер. Да
транслятор вычисляет размеры операндов и адреса меток за вас, но в остальном
не сказал бы, что есть какая-то существенная разница. Зная ассемблер,
например, вы можете в отладчике остановиться на вызове функции отображения
месседжбокса ("This program is not licensed"), промотать код немножко вверх и
заменить jne на je (например, обычно конечно всё сложнее) - и вот уже
программа принимает любой ключ, кроме собственно верного. Затем, зная, где
находится это место в коде - открываете какой-нибудь HIEW и патчите опкод
перехода руками. Просматривая голые hex-коды сделать то же самое будет гораздо
сложнее.

llvm-mc
#+begin_example
oleg@guixsd ~$ echo "0x33 0xc0 0x31 0xc0" | /gnu/store/…-llvm-10.0.0/bin/llvm-mc -mcpu=i686 -disassemble -show-inst
	.text
	xorl	%eax, %eax              # <MCInst #15207 XOR32rr_REV
                                        #  <MCOperand Reg:22>
                                        #  <MCOperand Reg:22>
                                        #  <MCOperand Reg:22>>
	xorl	%eax, %eax              # <MCInst #15206 XOR32rr
                                        #  <MCOperand Reg:22>
                                        #  <MCOperand Reg:22>
                                        #  <MCOperand Reg:22>>
#+end_example

* Learning
- [[https://github.com/brianrhall/Assembly][brianrhall/Assembly: Assembly Programming and Computer Architecture for Software Engineers]]

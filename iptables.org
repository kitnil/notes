:PROPERTIES:
:ID:       9cb7bab3-5342-4c3b-bd61-a5fd4a06dee8
:END:
: sysctl -w net.ipv4.conf.all.route_localnet=1

#+begin_example
  # Generated by iptables-save v1.6.0 on Fri Jun 26 14:52:04 2020
  ,*filter
  :INPUT ACCEPT [1293576:626675826]
  :FORWARD DROP [0:0]
  :OUTPUT ACCEPT [1176614:715727503]
  :DOCKER - [0:0]
  :DOCKER-ISOLATION-STAGE-1 - [0:0]
  :DOCKER-ISOLATION-STAGE-2 - [0:0]
  :DOCKER-USER - [0:0]
  COMMIT
  # Completed on Fri Jun 26 14:52:04 2020
  # Generated by iptables-save v1.6.0 on Fri Jun 26 14:52:04 2020
  ,*nat
  :PREROUTING ACCEPT [8351:486090]
  :INPUT ACCEPT [8150:470162]
  :OUTPUT ACCEPT [3259:194379]
  :POSTROUTING ACCEPT [0:0]
  :DOCKER - [0:0]
  -A PREROUTING -i eth1.80@eth1 -p tcp -m tcp -d 78.108.80.44/32 --dport 80 -j DNAT --to-destination 127.0.0.1:8080
  -A PREROUTING -i eth1.80@eth1 -p tcp -m tcp -d 78.108.80.44/32 --dport 443 -j DNAT --to-destination 127.0.0.1:8443
  -A POSTROUTING -j MASQUERADE
  COMMIT
  # Completed on Fri Jun 26 14:52:04 2020
#+end_example

- [[https://github.com/MaxKellermann/ferm][MaxKellermann/ferm: ferm is a frontend for iptables]]
- [[https://github.com/mrash/psad][mrash/psad: psad: Intrusion Detection and Log Analysis with iptables]]
- [[https://linuxconfig.org/collection-of-basic-linux-firewall-iptables-rules][Collection of basic Linux Firewall iptables rules - LinuxConfig.org]]
- [[https://logi.cc/en/2010/07/netfilter-log-format/][Netfilter Log Format]]
- [[https://github.com/Nudin/iptable_vis][Nudin/iptable_vis: visualise your iptables chains]]
- [[https://github.com/jpylypiw/easywall][jpylypiw/easywall: Web interface for easy use of the IPTables firewall on Linux systems written in Python3.]]
- [[https://github.com/bmaeser/iptables-boilerplate][bmaeser/iptables-boilerplate: rock solid default firewall-rules for webhosts]]
- [[https://webguy.vip/example-of-iptables/][Example of IPTABLES — Web Guy]]
- [[https://habr.com/ru/company/selectel/blog/511392/][xtables-addons: фильтруем пакеты по странам / Хабр]]
- [[https://github.com/pretty66/iptables-web][pretty66/iptables-web: golang开发的iptables web 管理程序]]
- [[https://github.com/guarandoo/nixos-iptables][guarandoo/nixos-iptables: A declarative module for iptables]]

- iptables -t nat -A POSTROUTING -o br0 -j MASQUERADE
- iptables -A FORWARD -i br0 -o br154.154 -m state --state RELATED,ESTABLISHED -j ACCEPT
- iptables -A FORWARD -i br154.154 -o br0 -j ACCEPT

- show counters
  : viddy /bin/sh -c "'sudo iptables -n -L -v; sudo iptables -n -L -v -t nat'"

- reset counters
  : sudo iptables -Z 

- iptables -A INPUT -p udp -m udp --dport 53 -m string --string "abacre" --algo kmp --to 1500 -j DROP

* Learning
- [[https://www.youtube.com/watch?v=NAdJojxENEU][(51) iptables Demystified - Port Redirection and Forwarding HTTP Traffic to another machine (part 1) - YouTube]]
- [[https://serverfault.com/questions/442708/can-i-use-iptables-on-my-varnish-server-to-forward-https-traffic-to-a-specific-s][iis - Can I use iptables on my Varnish server to forward HTTPS traffic to a specific server? - Server Fault]]
- [[https://habr.com/ru/articles/324276/][Iptables: немного о действии REDIRECT, его ограничениях и области применения / Хабр]]
- [[https://www.cyberciti.biz/tips/linux-iptables-examples.html][Linux 25 Iptables Netfilter Firewall Examples - nixCraft]]

* [[https://gist.github.com/tomasinouk/eec152019311b09905cd][Some examples of SNAT, DNAT with iptables with comments]]

    mainly used in start-up script

How to test 'safely'

When we play with iptables aka firewall we might end up in situation, where we execute rule, which has unforseen impact - lock yourself out. Recovering from this situation is necessity.

    How to:

        Enable reboot via SMS.
        Test all commands in shell first before putting them into Start-up script. This way the command will be wiped out, when unit is rebooted.

masquarade all outgoing packets to be WLAN0 IP

iptables -t nat -A PREROUTING -s 192.168.1.2 -i eth0 -j MASQUERADE

All packets leaving eth0 will have src eth0 ip address

iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 192.168.1.1

Match rule specifying a source port

    Below makes sure packets from Eth Devices have correct source IP Address Notice, when specifying a port, protocol needs to be specified as well

iptables -t nat -A POSTROUTING -o wlan0 -s 192.168.1.2 -p udp --dport 16020 -j SNAT --to 10.1.1.7:51889
iptables -t nat -A POSTROUTING -o wlan0 -s 192.168.1.2 -p tcp --dport 21 -j SNAT --to 10.1.1.7:21
iptables -t nat -A POSTROUTING -o wlan0 -s 192.168.1.3 -j SNAT --to 10.1.1.9


# Packets destined for IP 10.1.1.7 will be forwaded to 192.168.1.2 UDP,TCP
# Packets destined for IP 10.1.1.9 will be forwaded to 192.168.1.3 UDP,TCP
# Does work with ping (ICMP) correctly
iptables -t nat -A PREROUTING -i wlan0 -d 10.1.1.7 -j DNAT --to-destination 192.168.1.2
iptables -t nat -A PREROUTING -i wlan0 -d 10.1.1.9 -j DNAT --to-destination 192.168.1.3

Packets destined for IP 10.1.1.7 will be forwaded to 192.168.1.2 UDP,TCP

    Does NOT work with ping (ICMP) correctly, does not handle ICMP protocol WLAN IP reply on a ping without

iptables -t nat -A PREROUTING -p tcp -i wlan0 -d 10.1.1.7 -j DNAT --to-destination 192.168.1.2
iptables -t nat -A PREROUTING -p udp -i wlan0 -d 10.1.1.7 -j DNAT --to-destination 192.168.1.2

Change SNMP port of outgoing SNMP messages

iptables -t nat -A OUTPUT -p udp --dport 162 -j DNAT --to-destination 192.168.1.33:1162

Add secondary IP to WLAN0

ip addr add 10.1.1.7/24 dev wlan0
ip addr add 10.1.1.9/24 dev wlan0

List all IP addresses asign to wlan0

ip add list dev wlan0
All packets leaving eth1 will change source IP to 192.168.20.1

iptables -t nat -A POSTROUTING -o eth1 -j SNAT --to 192.168.20.1

All TCP packets leaving eth1 on port 443 will change source IP to 192.168.20.1

iptables -t nat -A POSTROUTING -o eth1 -s 192.168.1.22 -p tcp --dport 443 -j SNAT --to 192.168.20.1:443

All ICMP packets leaving eth1 will change source IP to 192.168.20.1

iptables -t nat -A POSTROUTING -o eth1 -s 192.168.1.22 -p icmp -j SNAT --to 192.168.20.1

All supported packets leaving eth1 which have source IP 192.168.1.22 will change source IP to 192.168.20.1

iptables -t nat -A POSTROUTING -o eth1 -s 192.168.1.22 -p all -j SNAT --to 192.168.20.1

SNAT on dynamically assign interface

    usage with WIFI dual mode where WiFi can be AP and STA at the same time add to start-up script

# assuming wlan1 is STA interface
ip=$(ip -o addr show up primary scope global wlan1 |
      while read -r num dev fam addr rest; do echo ${addr%/*}; done)
echo $ip

# all packets leaving wlan1 will change source IP to STA interface IP
iptables -t nat -A POSTROUTING -o wlan1 -j SNAT --to $ip

Block traffic from ETH0 to Cell except NTP

Order is important as the DROP will end up after allowing communication with NTP server. For that reason we need to INSERT the rules. If used APPEND the order of commands have to be reversed to ensure DROP is the last.

iptables -I FORWARD -i eth0 -o usb0 -j DROP
iptables -I FORWARD -d pool.ntp.org -i eth0 -o usb0 -j ACCEPT

Block traffic on ETH1 based on ports

Useful when you have a device behind the router and want to limit it's ability to use/exploit resources on the router.

    Use with caution as you can lock yourself out.

# Block port 80 (http) only on ETH1 interface
iptables -t filter -A INPUT -i eth1 -p tcp --dport 80 -j DROP
# Block port 443 (https) only on ETH1 interface
iptables -t filter -A INPUT -i eth1 -p tcp --dport 80 -j DROP
# Block port 22 (ssh) only on ETH1 interface
iptables -t filter-A INPUT -i eth1 -p tcp --dport 22 -j DROP
# Block ping (icmp) on ETH1 interface unit does not response to ping
iptables -t filter -A INPUT -i eth1 -p icmp -j DROP

Check NAT table

The iptables table needs to be specified for listing. EG. nat, mangle.

iptables -t nat -L -n -v

* ChatGPT

** How to transparently proxy a port from one IP address to another with iptables?

To transparently proxy a port from one IP address to another using iptables, you can use the REDIRECT target.

Here is an example command to redirect incoming traffic on port 80 from IP address 192.168.1.100 to IP address 192.168.1.200:

css

iptables -t nat -A PREROUTING -p tcp -d 192.168.1.100 --dport 80 -j DNAT --to-destination 192.168.1.200:80
iptables -t nat -A POSTROUTING -j MASQUERADE

This will redirect all incoming traffic to IP address 192.168.1.100 on port 80 to IP address 192.168.1.200 on port 80. The second line enables NAT so that the destination IP address is changed back to the original source IP address when the response is sent back.

Note that for this to work, the machine running iptables needs to have IP forwarding enabled. This can be done with the following command:

sysctl -w net.ipv4.ip_forward=1

Additionally, make sure to save the iptables rules so that they persist across reboots. This can be done with the following command:

javascript

iptables-save > /etc/iptables/rules.v4

This will save the current iptables rules to the specified file, which can then be loaded at boot time using the iptables-restore command.

To specify a more precise rule for enabling NAT and changing the destination IP address back to the original source IP address, you can use the following iptables command:

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -d 192.168.1.200 -p tcp --dport 80 -j SNAT --to-source 192.168.1.100

This command specifies the source network as 192.168.1.0/24 (change this to match your specific network), the destination IP address as 192.168.1.200, the protocol as TCP, and the destination port as 80 (change this to match the port you are forwarding). It then uses the SNAT target to change the source IP address to 192.168.1.100, which is the original source IP address of the incoming traffic.

Note that this rule should be used in addition to the DNAT rule in the previous answer, which forwards incoming traffic to the destination IP address. Together, these two rules will enable transparent proxying of the specified port from one IP address to another.

* PREROUTING vs OUTPUT

One needs to pay close attention between local packets, and network packets,
when using iptables. Local packets are packets created on the local machine,
whereas network packets are packets received. PREROUTING works on network
packets, for instance what you would get on a router device. Since in this
case it's all local, then one must use OUTPUT instead of PREROUTING to
redirect the packets. The necessary rule is therefore.

iptables -t nat -A OUTPUT     -p tcp --dport 4567 -j REDIRECT --to 8443

https://i.stack.imgur.com/ZCSl9.png

- [[https://stackoverflow.com/questions/64768982/http-iptable-prerouting-rule-is-not-working][nat - HTTP iptable PREROUTING rule is not working - Stack Overflow]]
  - [[https://danielmiessler.com/study/iptables/][An IPTABLES Primer - Daniel Miessler]]

* [[https://medium.com/itnext/tracing-kubernetes-services-4dc827abdc55][Tracing Kubernetes Services]]

Mar 18, 2024

Iptables is very brain hurty (I hope this is understood as a warning for what
the rest of this post will cover…)

If you have messed around with Kubernetes at all, you have undoubtedly had to
deploy or interact with a service at some point. How do services work, though?
This post will peak under the hood to see how services work. For a great read
on Kubernetes services in general and why they’re needed, see [[https://medium.com/@betz.mark/understanding-kubernetes-networking-services-f0cb48e4cc82][this post]] from
@mark.betz.

[[https://miro.medium.com/v2/resize:fit:307/1*Daj_wpMX8g2SAe4GQ5NJXA.png]]

** The Environment

Here is a quick description of the environment:

- RKE2 cluster running 1.28.4+rk2r1
- Calico CNI running v3.26.3 using a VxLAN overlay
- All nodes are running Ubuntu 22.04

** Fire Up a Workload

Before we can dig into the guts of a service, we need a workload and
service. The simple [[https://github.com/stefanprodan/podinfo][Podinfo]] web app will be used for this purpose.

#+begin_example
  # Add the Podinfo Helm repository if needed
  $ helm repo add podinfo https://stefanprodan.github.io/podinfo
  "podinfo" already exists with the same configuration, skipping

  # Update the all Helm repos to ensure the latest Podinfo will be used
  $ helm repo update
  Hang tight while we grab the latest from your chart repositories...
  ...Successfully got an update from the "podinfo" chart repository
  ...Successfully got an update from the "haproxytech" chart repository
  Update Complete. ⎈Happy Helming!⎈

  # Deploy podinfo into the target cluster
  $ helm upgrade -i --install --wait frontend --namespace podinfo \
  --set replicaCount=2 \
  --set backend=http://backend-podinfo:9898/echo \
  podinfo/podinfo
  Release "frontend" does not exist. Installing it now.
  NAME: frontend
  LAST DEPLOYED: Wed Mar 13 15:41:29 2024
  NAMESPACE: podinfo
  STATUS: deployed
  REVISION: 1
  NOTES:
  1. Get the application URL by running these commands:
    echo "Visit http://127.0.0.1:8080 to use your application"
    kubectl -n podinfo port-forward deploy/frontend-podinfo 8080:9898
#+end_example

Let’s see where this workload got scheduled:

[[https://miro.medium.com/v2/resize:fit:1200/1*Qn7uEFPrgXGTFl4F4JGtlQ.png]]

And let’s see what IP address was assigned to the service that was spun up:

[[https://miro.medium.com/v2/resize:fit:840/1*XDaSkRExSghRjGp16zNcHA.png]]

** Kube-proxy and Iptables

A quick sidebar is needed here to explain why the rest of this post will focus
on iptables. As Mark points out in his services post, iptables is the user
space program that fronts netfilter, a data plane packet processing engine
that can, among other things, redirect traffic to another destination.

Iptables is the default program that underpins kube-proxy in most Kubernetes
distributions. A list of the other programs that kube-proxy can use is found
[[https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-modes][here]]. This post is only valid for iptables based installations.

** Iptables Trace

This next section will be run from a cluster node that did not have a Podinfo
workload scheduled to it. Let’s enable tracing in iptables for traffic that
hits the destination port of 9898, the service port for Podinfo.

#+begin_src c
$ iptables -t raw -A PREROUTING -p tcp --dport 9898 -j TRACE
$ iptables -t raw -A OUTPUT -p tcp --dport 9898 -j TRACE
#+end_src

#+begin_quote
Note that since the above filter only captures a destination port of 9898,
this filter will not catch return traffic from the Podinfo service.
#+end_quote

The following command was run and left running from a second terminal session
with root privileges.
#+begin_src bash
  xtables-monitor --trace
#+end_src

Returning to the first terminal session, let’s curl against the Podinfo service:

#+begin_example
  $ curl http://10.43.156.98:9898
  {
    "hostname": "frontend-podinfo-7854c7cd4c-jvdx5",
    "version": "6.6.0",
    "revision": "357009a86331a987811fefc11be1350058da33fc",
    "color": "#34577c",
    "logo": "https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif",
    "message": "greetings from podinfo v6.6.0",
    "goos": "linux",
    "goarch": "amd64",
    "runtime": "go1.21.7",
    "num_goroutine": "8",
    "num_cpu": "8"
  }
#+end_example

Before proceeding any further, disable the packet trace, as this can log an
excessive amount of data on busy systems:

#+begin_src c
$ iptables -t raw -D PREROUTING -p tcp --dport 9898 -j TRACE
$ iptables -t raw -D OUTPUT -p tcp --dport 9898 -j TRACE
#+end_src

Jumping back to the terminal where the =xtables-monitor= command was running,
there was a [[https://raw.githubusercontent.com/TheFutonEng/k8s-svc-trace/main/trace.txt][ton of output]]. Let’s first talk about some columns in this mess:

#+begin_example
PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.43.156.98 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN
 TRACE: 2 0427ffe5 raw:OUTPUT:rule:0x18:CONTINUE  -4 -t raw -A OUTPUT -p tcp -m tcp --dport 9898 -j TRACE
 TRACE: 2 0427ffe5 raw:OUTPUT:return:
 TRACE: 2 0427ffe5 raw:OUTPUT:policy:ACCEPT
 TRACE: 2 0427ffe5 mangle:OUTPUT:return:
 TRACE: 2 0427ffe5 mangle:OUTPUT:policy:ACCEPT
PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.43.156.98 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN
 TRACE: 2 0427ffe5 nat:OUTPUT:rule:0xb9:JUMP:cali-OUTPUT  -4 -t nat -A OUTPUT -m comment --comment "cali:tVnHkvAo15HuiPy0" -j cali-OUTPUT
 TRACE: 2 0427ffe5 nat:cali-OUTPUT:rule:0xb8:JUMP:cali-fip-dnat  -4 -t nat -A cali-OUTPUT -m comment --comment "cali:GBTAv2p5CwevEyJm" -j cali-fip-dnat
 TRACE: 2 0427ffe5 nat:cali-fip-dnat:return:
 TRACE: 2 0427ffe5 nat:cali-OUTPUT:return:
 TRACE: 2 0427ffe5 nat:OUTPUT:rule:0x9:JUMP:KUBE-SERVICES  -4 -t nat -A OUTPUT -m comment --comment "kubernetes service portals" -j KUBE-SERVICES
 TRACE: 2 0427ffe5 nat:KUBE-SERVICES:rule:0x4aaa:JUMP:KUBE-SVC-Y4T5L63IYP3YFEBS  -4 -t nat -A KUBE-SERVICES -d 10.43.156.98/32 -p tcp -m comment --comment "podinfo/frontend-podinfo:http cluster IP" -j KUBE-SVC-Y4T5L63IYP3YFEBS
 TRACE: 2 0427ffe5 nat:KUBE-SVC-Y4T5L63IYP3YFEBS:rule:0x471b:JUMP:KUBE-MARK-MASQ  -4 -t nat -A KUBE-SVC-Y4T5L63IYP3YFEBS ! -s 10.42.0.0/16 -d 10.43.156.98/32 -p tcp -m comment --comment "podinfo/frontend-podinfo:http cluster IP" -j KUBE-MARK-MASQ
 TRACE: 2 0427ffe5 nat:KUBE-MARK-MASQ:rule:0x4aa4:CONTINUE  -4 -t nat -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
 TRACE: 2 0427ffe5 nat:KUBE-MARK-MASQ:return:
 TRACE: 2 0427ffe5 nat:KUBE-SVC-Y4T5L63IYP3YFEBS:rule:0x471d:JUMP:KUBE-SEP-OYNVDBAPYJ623W6H  -4 -t nat -A KUBE-SVC-Y4T5L63IYP3YFEBS -m comment --comment "podinfo/frontend-podinfo:http -> 10.42.54.194:9898" -j KUBE-SEP-OYNVDBAPYJ623W6H
 TRACE: 2 0427ffe5 nat:KUBE-SEP-OYNVDBAPYJ623W6H:rule:0x4721:ACCEPT  -4 -t nat -A KUBE-SEP-OYNVDBAPYJ623W6H -p tcp -m comment --comment "podinfo/frontend-podinfo:http" -m tcp -j DNAT --to-destination 10.42.54.194:9898
PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.42.54.194 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000
 TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x91:JUMP:cali-OUTPUT  -4 -t filter -A OUTPUT -m comment --comment "cali:tVnHkvAo15HuiPy0" -j cali-OUTPUT
 TRACE: 2 0427ffe5 filter:cali-OUTPUT:rule:0x8a:CONTINUE  -4 -t filter -A cali-OUTPUT -m comment --comment "cali:iC1pSPgbvgQzkUk_" -j MARK --set-xmark 0x0/0xf0000
 TRACE: 2 0427ffe5 filter:cali-OUTPUT:return:
 TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x17:JUMP:KUBE-PROXY-FIREWALL  -4 -t filter -A OUTPUT -m conntrack --ctstate NEW -m comment --comment "kubernetes load balancer firewall" -j KUBE-PROXY-FIREWALL
 TRACE: 2 0427ffe5 filter:KUBE-PROXY-FIREWALL:return:
 TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x12:JUMP:KUBE-SERVICES  -4 -t filter -A OUTPUT -m conntrack --ctstate NEW -m comment --comment "kubernetes service portals" -j KUBE-SERVICES
 TRACE: 2 0427ffe5 filter:KUBE-SERVICES:return:
 TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x6:JUMP:KUBE-FIREWALL  -4 -t filter -A OUTPUT -j KUBE-FIREWALL
 TRACE: 2 0427ffe5 filter:KUBE-FIREWALL:return:
 TRACE: 2 0427ffe5 filter:OUTPUT:return:
 TRACE: 2 0427ffe5 filter:OUTPUT:policy:ACCEPT
PACKET: 2 0427ffe5 OUT=vxlan.calico SRC=192.168.1.88 DST=10.42.54.194 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000
 TRACE: 2 0427ffe5 mangle:POSTROUTING:rule:0x15:JUMP:cali-POSTROUTING  -4 -t mangle -A POSTROUTING -m comment --comment "cali:O3lYWMrLQYEMJtB5" -j cali-POSTROUTING
 TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:rule:0x12:CONTINUE  -4 -t mangle -A cali-POSTROUTING -m comment --comment "cali:nnqPh8lh2VOogSzX" -j MARK --set-xmark 0x0/0xf0000
 TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:rule:0x13:JUMP:cali-to-host-endpoint  -4 -t mangle -A cali-POSTROUTING -m comment --comment "cali:nquN8Jw8Tz72pcBW" -m conntrack --ctstate DNAT -j cali-to-host-endpoint
 TRACE: 2 0427ffe5 mangle:cali-to-host-endpoint:return:
 TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:return:
 TRACE: 2 0427ffe5 mangle:POSTROUTING:return:
 TRACE: 2 0427ffe5 mangle:POSTROUTING:policy:ACCEPT
PACKET: 2 0427ffe5 OUT=vxlan.calico SRC=192.168.1.88 DST=10.42.54.194 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000
 TRACE: 2 0427ffe5 nat:POSTROUTING:rule:0xba:JUMP:cali-POSTROUTING  -4 -t nat -A POSTROUTING -m comment --comment "cali:O3lYWMrLQYEMJtB5" -j cali-POSTROUTING
 TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb5:JUMP:cali-fip-snat  -4 -t nat -A cali-POSTROUTING -m comment --comment "cali:Z-c7XtVd2Bq7s_hA" -j cali-fip-snat
 TRACE: 2 0427ffe5 nat:cali-fip-snat:return:
 TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb6:JUMP:cali-nat-outgoing  -4 -t nat -A cali-POSTROUTING -m comment --comment "cali:nYKhEzDlr11Jccal" -j cali-nat-outgoing
 TRACE: 2 0427ffe5 nat:cali-nat-outgoing:return:
 TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb7:ACCEPT  -4 -t nat -A cali-POSTROUTING -o vxlan.calico -m comment --comment "cali:e9dnSgSVNmIcpVhP" -m addrtype ! --src-type LOCAL --limit-iface-out -m addrtype --src-type LOCAL -j MASQUERADE --random-fully
#+end_example

- PACKET :: This indicates the beginning of a new packet event. It signifies
  that the line contains information about a packet that is being processed,
  including its source, destination, length, and other packet-level
  details. The =PACKET:= lines also contain the outgoing interface based on
  the current destination IP address of the packet.
- TRACE :: This indicates a tracing line that follows a packet's path through
  the various iptables chains and rules. Each “TRACE” line represents a step
  in the packet's processing, showing which rule or chain the packet is
  currently being evaluated against.
- Protocol Number :: This is the =2=after =TRACE:=or =PACKET:= , and it
  represents AF\_INET in this case (IPv4 traffic).
- Packet Identifier :: The value =0427ffe5= in the above output serves as a
  unique packet identifier, allowing for the correlation of trace messages of
  a specific packet.
- Table:Chain :: for =TRACE= entries, the next column refers to the iptables
  table and chain that is processing the packet. In the case of the second
  packet, =raw:OUTPUT= refers to the =raw= table and the =OUTPUT= chain. To
  show just that iptables chain, run =sudo iptables -t raw -L OUTPUT -n
  --line-numbers=

One other important piece of data is understanding how netfilter processes
packets. For a packet originating on a system, the order is:

1. Routing
2. Raw (OUTPUT)
3. Mangle (OUTPUT)
4. NAT (OUTPUT)
5. Filter (OUTPUT)
6. Routing
7. Mangle (POSTROUTING)
8. NAT (POSTROUTING)

More details can be found [[https://rlworkman.net/howtos/iptables/chunkyhtml/c962.html][here]], specifically in section 6–2. The below diagram
from [[https://en.wikipedia.org/wiki/Netfilter#/media/File:Netfilter-packet-flow.svg][Wikipedia]] is also a great reference to show the packet processing order.

[[https://miro.medium.com/v2/resize:fit:3120/0*cAhNpGinxEmZ0jkK.png]]

*Figure 1: Wikipedia Netfilter Packet Processing Diagram*

To be more explicit, this is the section of the diagram that the rest of this
post will focus on:

[[https://miro.medium.com/v2/resize:fit:840/1*37Fy0VasvKF-pm6Z9odUeQ.png]]

*Figure 2: Zoomed in Picture of the Output Network Processing*

With this context, let’s dive into how packet =0427ff35=  is being processed.

** Raw Table

The purpose of the =raw= table is to provide a way for packets to bypass the
connection track ([[https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows][conntrack]]) functionality within iptables. This functionality
is not used for this flow, so this table is processed pretty quickly:

#+begin_example
  PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.43.156.98 LEN=60 \
  TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN

  TRACE: 2 0427ffe5 raw:OUTPUT:rule:0x18:CONTINUE  -4 -t raw -A OUTPUT \
  -p tcp -m tcp --dport 9898 -j TRACE

  TRACE: 2 0427ffe5 raw:OUTPUT:return:

  TRACE: 2 0427ffe5 raw:OUTPUT:policy:ACCEPT
#+end_example

The first line is informational. It shows the receipt of the packet and the
start of the processing. Note that the SRC, =192.168.1.88= , is the source IP
address of the node that initiated the curl request.

The second line processed is the =TRACE= that was implemented earlier in this
post to produce the captured =xtables-monitor= output ( =iptables -t raw -A
PREROUTING -p tcp --dport 9898 -J TRACE= ).

The third and fourth lines show that the ultimate result of the process on the
=raw= table is an =ACCEPT= target. The =ACCEPT= target means to pass the
packet to the next table. Recall the relevant tables and chains can be viewed
via =iptables= commands.

#+begin_example
$ iptables -t raw -L OUTPUT -n --line-numbers
Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    cali-OUTPUT  all  --  0.0.0.0/0            0.0.0.0/0            /* cali:tVnHkvAo15HuiPy0 */

$ iptables -t raw -L cali-OUTPUT -n --line-numbers
Chain cali-OUTPUT (1 references)
num  target     prot opt source               destination         
1    MARK       all  --  0.0.0.0/0            0.0.0.0/0            /* cali:njdnLwYeGqBJyMxW */ MARK and 0xfff0ffff
2    cali-to-host-endpoint  all  --  0.0.0.0/0            0.0.0.0/0            /* cali:rz86uTUcEZAfFsh7 */
3    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            /* cali:pN0F5zD0b8yf9W1Z */ mark match 0x10000/0x10000

$ iptables -t raw -L cali-to-host-endpoint -n --line-numbers
Chain cali-to-host-endpoint (1 references)
num  target     prot opt source               destination
#+end_example

The way the above output is traversed is as follows:

[[https://miro.medium.com/v2/resize:fit:769/1*3L8Nm2iihGNuEG5iBOJhyA.png]]

*Figure 3: Flow Diagram Raw to Mangle*

The first rule in the =cali-OUTPUT= chain is a =MARK= rule. It’s not clear why
this rule didn’t show up in the =xtables-monitor= output, but the working
theory is that this rule ultimately did not impact how the packet was
forwarded and was thus not included. The =MARK= target is a non-terminating
target, meaning that processing in the current chain continues even if the
=MARK= rule fires.

** State of the Packet

State of the packet leaving the =raw:OUTPUT=  chain:

Source IP address: 192.168.1.88  
Source Port: 49058  
Destination IP address: 10.43.156.98  
Destination Port: 9898

** Mangle Table — OUTPUT

As the name suggests, the mangle table is used to modify the packet in some
way. A typical modification would be to change the TTL or ToS/DSCP fields
inside [[https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Header][the IPv4 header]]. Like =raw:OUTPUT=, the processing here is quick. The
packet quickly hits an =ACCEPT= target and processing goes to the next table.

#+begin_example
  TRACE: 2 0427ffe5 mangle:OUTPUT:return:
  TRACE: 2 0427ffe5 mangle:OUTPUT:policy:ACCEPT
#+end_example

** State of the Packet

State of the packet leaving the =mangle:OUTPUT=  chain:

Source IP address: 192.168.1.88  
Source Port: 49058  
Destination IP address: 10.43.156.98  
Destination Port: 9898  
Output interface: enp3s0  
Mark: none

** NAT Table — OUTPUT

There’s a much heavier lift in terms of packet processing in the =nat:OUTPUT=  table.

#+begin_example
  00: PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.43.156.98 LEN=60 \
  TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN

  01: TRACE: 2 0427ffe5 nat:OUTPUT:rule:0xb9:JUMP:cali-OUTPUT  -4 -t nat \
  -A OUTPUT -m comment --comment "cali:tVnHkvAo15HuiPy0" -j cali-OUTPUT

  02: TRACE: 2 0427ffe5 nat:cali-OUTPUT:rule:0xb8:JUMP:cali-fip-dnat  -4 \
  -t nat -A cali-OUTPUT -m comment --comment "cali:GBTAv2p5CwevEyJm" \
  -j cali-fip-dnat

  03: TRACE: 2 0427ffe5 nat:cali-fip-dnat:return:

  04: TRACE: 2 0427ffe5 nat:cali-OUTPUT:return:

  05: TRACE: 2 0427ffe5 nat:OUTPUT:rule:0x9:JUMP:KUBE-SERVICES  -4 \
  -t nat -A OUTPUT -m comment --comment "kubernetes service portals" \
  -j KUBE-SERVICES

  06: TRACE: 2 0427ffe5 nat:KUBE-SERVICES:rule:0x4aaa:JUMP:KUBE-SVC-Y4T5L63IYP3YFEBS  \
  -4 -t nat -A KUBE-SERVICES -d 10.43.156.98/32 -p tcp -m comment \
  --comment "podinfo/frontend-podinfo:http cluster IP" \
  -j KUBE-SVC-Y4T5L63IYP3YFEBS

  07: TRACE: 2 0427ffe5 nat:KUBE-SVC-Y4T5L63IYP3YFEBS:rule:0x471b:JUMP:KUBE-MARK-MASQ \
  -4 -t nat -A KUBE-SVC-Y4T5L63IYP3YFEBS ! -s 10.42.0.0/16 -d 10.43.156.98/32 \
  -p tcp -m comment --comment "podinfo/frontend-podinfo:http cluster IP" \
  -j KUBE-MARK-MASQ

  08: TRACE: 2 0427ffe5 nat:KUBE-MARK-MASQ:rule:0x4aa4:CONTINUE  \
  -4 -t nat -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000

  09: TRACE: 2 0427ffe5 nat:KUBE-MARK-MASQ:return:

  10: TRACE: 2 0427ffe5 nat:KUBE-SVC-Y4T5L63IYP3YFEBS:rule:0x471d:JUMP:KUBE-SEP-OYNVDBAPYJ623W6H  \
  -4 -t nat -A KUBE-SVC-Y4T5L63IYP3YFEBS -m comment \
  --comment "podinfo/frontend-podinfo:http -> 10.42.54.194:9898" \
  -j KUBE-SEP-OYNVDBAPYJ623W6H

  11: TRACE: 2 0427ffe5 nat:KUBE-SEP-OYNVDBAPYJ623W6H:rule:0x4721:ACCEPT  \
  -4 -t nat -A KUBE-SEP-OYNVDBAPYJ623W6H -p tcp -m comment \
  --comment "podinfo/frontend-podinfo:http" -m tcp \
  -j DNAT --to-destination 10.42.54.194:9898
#+end_example

The first five lines show processing going from =nat:OUTPUT=, to
=nat:cali-OUTPUT=, to =nat:cali-fip-dnat=, before returning all the way to
=nat:OUTPUT= and processing the next rule in that chain which is
=nat:KUBE-SERVICES= .

Processing in =nat:KUBE-SERVICES= chain starts in the fifth line and the next
matching chain is =nat:KUBE-SVC-Y4T5L63IYP3YFEBS= based on the destination IP
address of the service (10.43.156.98).

Line eight then forwards processing to the =nat:KUBE-MARK-MASQ= chain since
the packet's source address is not in the 10.42.0.0/16 subnet (basically, the
source isn’t another pod). The sole entry in this chain marks the packet with
=0x4000=, done in line nine. This mark has node local significance and does
not follow the packet to any other server/hop once leaving this node. It will
be used later in the processing of the packet. Line 10 then returns processing
to the =nat:KUBE-SVC-Y4T5L63IYP3YFEBS= chain.

Line 11 is where the load balancing within kube-proxy happens in iptables
mode, which is best seen in the iptables output for the chain:

#+begin_example
$ iptables -t nat -L KUBE-SVC-Y4T5L63IYP3YFEBS -n --line-numbers
Chain KUBE-SVC-Y4T5L63IYP3YFEBS (1 references)
num  target     prot opt source               destination         
1    KUBE-MARK-MASQ  tcp  -- !10.42.0.0/16         10.43.156.98         
/* podinfo/frontend-podinfo:http cluster IP */

2    KUBE-SEP-6G2GMHWEBXQ5W3DV  all  --  0.0.0.0/0            0.0.0.0/0     
/* podinfo/frontend-podinfo:http -> 10.42.217.66:9898 */ 
statistic mode random probability 0.50000000000

3    KUBE-SEP-OYNVDBAPYJ623W6H  all  --  0.0.0.0/0            0.0.0.0/0            
/* podinfo/frontend-podinfo:http -> 10.42.54.194:9898 */
#+end_example

Note the presence of =statistic mode random probability 0.50000000000= in the
second rule, which means exactly what it sounds like. This rule will fire 50%
of the time and forward processing of the packet to the
=nat:KUBE-SEP-6G2GMHWEBXQ5W3DV= chain. When this chain is not selected,
processing falls through to the =nat:KUBE-SEP-OYNVDBAPYJ623W6H= chain. These
two =SEP= chains each have the same function: a destination NAT action to
update the destination IP address from the service address of =10.43.156.98=to
that of one of the two pods deployed for the Podinfo service. The chain ending
in =W3DV= forwards to the pod with IP address =10.42.217.66=, and the chain
ending in =3W6h= forwards to the pod with IP address =10.43.54.194=. This
particular packet happened to load balance =10.43.54.194= so line 11 shows the
jump from the =SVC= chain to the =SEP= chain for the =10.43.54.194=
pod. Finally, line 12 show the =DNAT= action actually happening and the
destination IP address is now =10.42.54.194= .

[[https://miro.medium.com/v2/resize:fit:840/1*ONf1it9J52XS9R-cvTuBKw.png]]

*Figure 4: Flow Diagram NAT to Filter*

** State of the Packet

State of the packet leaving the =nat:OUTPUT=  chain:

Source IP address: 192.168.1.88  
Source Port: 49058  
Destination IP address: 10.42.54.194  
Destination Port: 9898  
Output interface: enp3s0  
Mark: 0x4000/0x4000

** Filter Table — OUTPUT

The filter table is used to restrict traffic from leaving the host. With that
description, no significant change in processing is anticipated here.

#+begin_example
00: PACKET: 2 0427ffe5 OUT=enp3s0 SRC=192.168.1.88 DST=10.42.54.194 \
LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000

01: TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x91:JUMP:cali-OUTPUT  -4 \
-t filter -A OUTPUT -m comment --comment "cali:tVnHkvAo15HuiPy0" \
-j cali-OUTPUT

02: TRACE: 2 0427ffe5 filter:cali-OUTPUT:rule:0x8a:CONTINUE  -4 \
-t filter -A cali-OUTPUT -m comment --comment "cali:iC1pSPgbvgQzkUk_" \
-j MARK --set-xmark 0x0/0xf0000

03: TRACE: 2 0427ffe5 filter:cali-OUTPUT:return:

04: TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x17:JUMP:KUBE-PROXY-FIREWALL  -4 \
-t filter -A OUTPUT -m conntrack --ctstate NEW -m comment \
--comment "kubernetes load balancer firewall" -j KUBE-PROXY-FIREWALL

05: TRACE: 2 0427ffe5 filter:KUBE-PROXY-FIREWALL:return:

06: TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x12:JUMP:KUBE-SERVICES  -4 \
-t filter -A OUTPUT -m conntrack --ctstate NEW -m comment \
--comment "kubernetes service portals" -j KUBE-SERVICES

07: TRACE: 2 0427ffe5 filter:KUBE-SERVICES:return:

08: TRACE: 2 0427ffe5 filter:OUTPUT:rule:0x6:JUMP:KUBE-FIREWALL  -4 \
-t filter -A OUTPUT -j KUBE-FIREWALL

09: TRACE: 2 0427ffe5 filter:KUBE-FIREWALL:return:

10: TRACE: 2 0427ffe5 filter:OUTPUT:return:

11: TRACE: 2 0427ffe5 filter:OUTPUT:policy:ACCEPT
#+end_example

The first =TRACE= entry shows the processing of the packet from the
=filter:OUTPUT= chain to the =filter:cali-OUTPUT= chain. The
=filter:cali-OUTPUT= chain updates the marking on the packet and then passes
processing back to the =filter:OUTPUT= chain in line three (note, the marking
on the packet doesn’t actually change due to the bitwise =AND= operation
between =0xf000=and =0x4000= ). The rest of the processing goes through
various Kubernetes specific chains, which ultimately make no changes and
accept the packet.

This execution does perform some useful processing, however. Note the lines
that have =-m conntrack -ctstate NEW= in them. Since this is a TCP SYN packet
(the first packet in a three-way handshake), this packet is subject to more
scrutiny. The aforementioned lines serve to update the connection table used
by iptables. Note that in the full raw =xtable-monitor --trace= [[https://raw.githubusercontent.com/TheFutonEng/k8s-svc-trace/main/trace.txt][output]],
subsequent packets have far fewer lines.

** State of the Packet

State of the packet leaving the =nat:OUTPUT=  chain:

Source IP address: 192.168.1.88  
Source Port: 49058  
Destination IP address: 10.42.54.194  
Destination Port: 9898  
Output interface: enp3s0  
Mark: 0x4000/0x4000

** Mangle Table — POSTROUTING

Again, the purpose of the mangle tables is to modify the packet, mostly in the
TTL and ToS/DSCP headers. Given that, no major changes are expected here
either.

#+begin_example
00: PACKET: 2 0427ffe5 OUT=vxlan.calico SRC=192.168.1.88 DST=10.42.54.194 \
LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000

01: TRACE: 2 0427ffe5 mangle:POSTROUTING:rule:0x15:JUMP:cali-POSTROUTING  -4 \
-t mangle -A POSTROUTING -m comment --comment "cali:O3lYWMrLQYEMJtB5" \
-j cali-POSTROUTING

02: TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:rule:0x12:CONTINUE  -4 \
-t mangle -A cali-POSTROUTING -m comment --comment "cali:nnqPh8lh2VOogSzX" \
-j MARK --set-xmark 0x0/0xf0000

03: TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:rule:0x13:JUMP:cali-to-host-endpoint  \
-4 -t mangle -A cali-POSTROUTING -m comment --comment "cali:nquN8Jw8Tz72pcBW" \
-m conntrack --ctstate DNAT -j cali-to-host-endpoint

04: TRACE: 2 0427ffe5 mangle:cali-to-host-endpoint:return:

05: TRACE: 2 0427ffe5 mangle:cali-POSTROUTING:return:

06: TRACE: 2 0427ffe5 mangle:POSTROUTING:return:

07: TRACE: 2 0427ffe5 mangle:POSTROUTING:policy:ACCEPT
#+end_example

Another “updated marking” happens in line 2 but the operation doesn’t change the mark from =0x40000= .

** State of the Packet

State of the packet leaving the =nat:OUTPUT=  chain:

Source IP address: 192.168.1.88  
Source Port: 49058  
Destination IP address: 10.42.54.194  
Destination Port: 9898  
Output interface: vxlan.calico  
Mark: 0x4000/0x4000

A more notable change in the state of the packet is indirectly due to an
iptables modification. The destination IP address of the packet changed in the
=nat:OUTPUT= chain from the service address of =10.43.156.98= to the pod
address of =10.42.54.194=. A routing lookup against the pod address happened
after this change, and the outgoing interface is indeed =vxlan.calico= :

#+begin_example
$ ip route get 10.42.54.194
10.42.54.194 via 10.42.54.193 dev vxlan.calico src 10.42.135.130 uid 0 
    cache 
#+end_example

This means that the VxLAN overlay will deliver the packet from the node where
the request was initiated to the node where the pod is running, and the “state
of the packet” headers that have been tracking in this post will be what the
destination node processes after popping off the VxLAN encapsulation. All of
the VxLAN processing happens outside of iptables.

[[https://miro.medium.com/v2/resize:fit:576/1*UnqzHq6DDR5xvosmE6IKWA.gif]]

*Figure 5: I told you this was going to be brain hurty…*

** NAT Table — POSTROUTING

The NAT table would handle any source or destination NAT changes to the
packet. Since the destination was already updated, no further modifications
really happened here:

#+begin_example
00: PACKET: 2 0427ffe5 OUT=vxlan.calico SRC=192.168.1.88 DST=10.42.54.194 LEN=60 TOS=0x0 TTL=64 ID=45471DF SPORT=49058 DPORT=9898 SYN MARK=0x4000

01: TRACE: 2 0427ffe5 nat:POSTROUTING:rule:0xba:JUMP:cali-POSTROUTING  -4 \
-t nat -A POSTROUTING -m comment --comment "cali:O3lYWMrLQYEMJtB5" \
-j cali-POSTROUTING

02: TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb5:JUMP:cali-fip-snat  -4 \
-t nat -A cali-POSTROUTING -m comment --comment "cali:Z-c7XtVd2Bq7s_hA" \
-j cali-fip-snat

03: TRACE: 2 0427ffe5 nat:cali-fip-snat:return:

04: TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb6:JUMP:cali-nat-outgoing  \
-4 -t nat -A cali-POSTROUTING -m comment --comment "cali:nYKhEzDlr11Jccal" \
-j cali-nat-outgoing

05: TRACE: 2 0427ffe5 nat:cali-nat-outgoing:return:

06: TRACE: 2 0427ffe5 nat:cali-POSTROUTING:rule:0xb7:ACCEPT  -4 -t nat \
-A cali-POSTROUTING -o vxlan.calico -m comment \
--comment "cali:e9dnSgSVNmIcpVhP" -m addrtype ! --src-type LOCAL \
--limit-iface-out -m addrtype --src-type LOCAL -j MASQUERADE --random-fully
#+end_example

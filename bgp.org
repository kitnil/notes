:PROPERTIES:
:ID:       63242a98-634c-4236-999c-5b26d588b4d9
:END:
#+title: BGP

- [[https://habr.com/ru/post/211176/][Защита от DDOS атак средствами BGP / Хабр]]
- [[https://www.jordanwhited.com/posts/corebgp-plugging-in-to-bgp/][CoreBGP - Plugging in to BGP | Jordan Whited]]
- [[https://github.com/jwhited/corebgp][jwhited/corebgp: CoreBGP is a BGP library written in Go that implements the BGP FSM with an event-driven, pluggable model.]]
- [[https://github.com/RIPE-NCC/bgpdump][RIPE-NCC/bgpdump: Utility and C Library for parsing MRT files]]
- [[https://github.com/osrg/rustybgp][osrg/rustybgp: BGP implemented in the Rust Programming Language]]
- [[https://github.com/osrg/gobgp][osrg/gobgp: BGP implemented in the Go Programming Language]]
- [[https://github.com/osrg/bgperf][osrg/bgperf]]
- [[https://isbgpsafeyet.com/][Is BGP safe yet? · Cloudflare]]
- [[https://www.ssi.gouv.fr/uploads/2016/03/bgp-configuration-best-practices.pdf][bgp-configuration-best-practices.pdf]]
- [[https://peeringdb.com/net/10572][PeeringDB DataIX]]
- [[https://techstat.net/bgp-how-to-configure-basic-multipathload-balancing/][BGP - How to configure basic Multipath/Load balancing - Techstat]]
- [[https://blog.benjojo.co.uk/post/bgp-battleships][Playing battleships over BGP]]
- [[https://habr.com/ru/post/184350/][Сети для самых маленьких. Часть восьмая. BGP и IP SLA / Хабр]]
- [[https://q05t9n.wordpress.com/2016/02/08/2-%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D1%8B-bgp-%D0%B8-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80-%D0%BF%D1%83%D1%82%D0%B8/][2. Атрибуты BGP и выбор пути. – q05t9n goes ccnp]]
- [[https://github.com/Exa-Networks/exabgp/wiki/Controlling-ExaBGP-:-possible-options-for-process][Controlling ExaBGP : possible options for process · Exa-Networks/exabgp Wiki]]
- [[https://erco.xyz/][Erco: Exabgp Routes Controller]]
- [[https://thepacketgeek.com/exabgp/getting-started/][ExaBGP and Python Getting Started - thePacketGeek]]
- [[https://www.dasblinkenlichten.com/working-with-exabgp-4/][Working with ExaBGP 4 – Das Blinken Lichten]]
- [[https://github.com/faucetsdn/ryu][faucetsdn/ryu: Ryu component-based software defined networking framework]]
- [[https://www.noction.com/blog/bgp-flow-specification-version-2][BGP Flow Specification Version 2 | Noction]]
- [[https://github.com/inex/IXP-Manager][inex/IXP-Manager: Full stack web application powering peering at ~200 Internet Exchange Points (IXPs) globally.]]
- [[https://bgp.he.net/][Hurricane Electric BGP Toolkit]]
- [[https://en.wikipedia.org/wiki/Resource_Public_Key_Infrastructure][Resource Public Key Infrastructure - Wikipedia]]

* Looking glass
- [[http://lg.level3carrier.com/lg/lg.cgi][AS58682 Looking Glass]]
- [[https://lg.telia.net/][Telia Looking Glass]]
- [[https://lg.he.net/][Looking Glass - Hurricane Electric (AS6939)]]
- [[https://looking.house/point.php?id=86][Point in Netherlands, Amsterdam, data center Datacenter.com from Eurobyte]]
- [[https://www.msk-ix.ru/en/lookingglass/][LG :: MSK-IX]]
- [[https://looking.house/index.php][Looking Glass points: execute host, ping, traceroute and mtr commands for domain name and IPv4 or IPv6 addresses]]
- [[https://bgpview.io/asn/43362#upstreams-v4][AS43362 Hosting Ltd BGP Network Information - BGPView]]
- [[https://github.com/mehrdadrad/mylg][mehrdadrad/mylg: Network Diagnostic Tool]]

** [[http://lg.mtu.ru/cgi-bin/lgform_img.cgi][MTS]]
Our PeeringDB page: as8359
Our Peering Policy page: here
Should you have any questions, please contact noc@mtu.ru

* RIPE
- [[https://apps.db.ripe.net/db-web-ui/query?bflag=&searchtext=AS-DATAIX&source=RIPE#resultsSection][Webupdates — RIPE Network Coordination Centre]]
- [[https://habr.com/ru/company/linxdatacenter/blog/526508/][Основы работы с базой данных RIPE / Хабр]]

Полезные запросы whois:

- Посмотреть шаблон объекта.
  : whois -t object_type

- Узнать все маршруты, которые происходят из автономной системы.
  : whois -T route -i origin ASxxxxx

- Узнать все объекты, которые защищены объектом «maintainer_name».
  : whois -i mnt-by maintainer_name

- Узнать, на какие более мелкие подсети поделена подсеть «subnet».
  : whois -M subnet

- Узнать, из какой более крупной подсети образована подсеть «subnet».
  : whois -L subnet

* Tools
- [[https://github.com/bgpfix/bgpipe][bgpfix/bgpipe: BGP reverse proxy]]
- [[https://github.com/smartbgp/yabgp][smartbgp/yabgp: :bowtie:Yet Another BGP Python Implementation]]

* Learning
- [[https://antiddos.biz/nastrojka-bgp-marshrutizacii-dlya-raboty-s-sobstvennoj-setyu/][Настройка BGP маршрутизации для работы с собственной сетью. - AntiDDoS.biz]]
  - [[https://dn42.eu/Home][dn42 is a big dynamic VPN, which employs Internet technologies (BGP, whois database, DNS, etc).]]
- [[https://github.com/leahneukirchen/docker-lab-bgp][leahneukirchen/docker-lab-bgp: A small BGP lab in Docker]]
- [[https://linkmeup.ru/blog/1198/][Сети для самых маленьких. Часть восьмая. BGP и IP SLA - linkmeup]]
- [[https://www.youtube.com/playlist?list=PLxbwE86jKRgMpuZuLBivzlM8s2Dk5lXBQ][Free CCNA 200-301 | Complete Course 2022 - YouTube]]
- [[https://habr.com/ru/post/282532/][Ищем свободные IPv4 в BGP full-view / Хабр]]
- [[https://linkmeup.ru/blog/1201/][Сети для самых маленьких. Микровыпуск №3. IBGP - linkmeup]]

** BGP

BGP stands for Border Gateway Protocol, which is a standardized exterior gateway protocol designed to exchange routing and reachability information between routers in different autonomous systems (AS) on the Internet.

BGP is used to build routing tables in routers that direct packets between networks, and it enables routers to make informed decisions on which paths to use when forwarding packets. The information exchanged between routers using BGP includes the destination network, the next hop to the destination network, and various attributes that describe the characteristics of the path, such as its cost, reliability, and latency.

BGP is an important component of the Internet's infrastructure and plays a crucial role in enabling the interconnectivity of different networks and ensuring that data can be reliably and efficiently routed from one place to another.

** What is BGP full view?

A "BGP full view" refers to the complete set of BGP routing information that a router has learned from its neighbors. In BGP, routers exchange information about the routes they know about and update their routing tables accordingly. The full view includes all of the BGP routes that the router has learned from its neighbors, including information about the destination network, the next hop, and the various attributes that describe the path.

Having a full view of the BGP routing information is important for routers in making informed decisions about how to forward packets. The full view allows routers to determine the best paths to use for forwarding packets and to detect and avoid potential routing loops.

In some cases, a router may not have a full view of the BGP routing information due to a lack of neighbors, limited resources, or other factors. In these cases, the router may only have a partial view of the BGP routing information, which can result in suboptimal routing decisions and increased latency.

** Use cases for BG full view?

There are several use cases for a BGP full view:

    Internet Service Providers (ISPs): ISPs use BGP to exchange routing information with other ISPs and to build routing tables that allow them to direct traffic between their networks and the Internet. Having a full view of the BGP routing information is important for ISPs because it allows them to make informed decisions about how to forward traffic, ensure that traffic is being routed over the most efficient paths, and avoid potential routing loops.

    Data Centers: Data centers use BGP to interconnect their networks and to ensure that traffic is being routed between their networks in an efficient and reliable manner. A full view of the BGP routing information is important for data centers because it allows them to make informed decisions about how to forward traffic, avoid potential routing loops, and ensure that traffic is being routed over the most efficient paths.

    Enterprises: Enterprises use BGP to interconnect their networks and to ensure that traffic is being routed between their networks in an efficient and reliable manner. A full view of the BGP routing information is important for enterprises because it allows them to make informed decisions about how to forward traffic, avoid potential routing loops, and ensure that traffic is being routed over the most efficient paths.

    Government Agencies: Government agencies use BGP to interconnect their networks and to ensure that traffic is being routed between their networks in an efficient and reliable manner. A full view of the BGP routing information is important for government agencies because it allows them to make informed decisions about how to forward traffic, avoid potential routing loops, and ensure that traffic is being routed over the most efficient paths.

Overall, having a full view of the BGP routing information is important for ensuring efficient and reliable routing of traffic on the Internet.

** What is public abstract class in Java?

A public abstract class in Java is a class that has been declared as public, meaning it can be accessed from anywhere in the code, and abstract, meaning it cannot be instantiated and must be subclassed. Abstract classes are used to provide a common interface for a group of related classes. They can contain both abstract and non-abstract methods, but typically abstract classes contain mostly abstract methods which must be overridden by any concrete subclasses. The purpose of having an abstract class is to define a common structure or behavior that can be shared among several classes.

** What is public abstract method in Java?

A public abstract method in Java is a method declared with the "public" and "abstract" keywords. The "public" keyword makes the method accessible from anywhere in the program, while the "abstract" keyword means that the method has no implementation, and must be overridden in a subclass. Abstract methods can only be declared in abstract classes, which cannot be instantiated on their own. When a subclass extends an abstract class, it must provide implementations for all of the abstract methods declared in the abstract class.

** What is public final method in Java?

A public final method in Java is a method that is declared with the "public" and "final" keywords. The "public" keyword means that the method can be accessed and used by any code outside of the class in which it is declared. The "final" keyword means that the method cannot be overridden or changed by any subclass. Once a public final method is defined in a class, it cannot be changed in any subclass. This is useful in cases where the method represents some essential behavior that should always remain the same, regardless of any changes made in subclasses.

** What is protected abstract method in Java?

In Java, a protected abstract method is a method declared with the protected access modifier and the abstract keyword. This means that the method is only accessible within the same package or from a subclass of the class that declares the method. An abstract method is a method that has no implementation, it is just a declaration, and it is meant to be overridden by subclasses.

When a class contains an abstract method, it must also be declared as abstract. An abstract class cannot be instantiated, it is only meant to be subclassed. When a subclass extends an abstract class, it must implement all of the abstract methods in the superclass.

** What is less-than sign near class name?

The less-than sign (<) near a class name in Java is used to specify type parameters for a generic class. Generics were introduced in Java 5 to provide a type-safe way of creating and using collections. A generic class is a class that can work with any data type, rather than being specific to a single type. The type parameter is specified between angle brackets, and it acts as a placeholder for the actual data type that will be used when the class is instantiated. For example, a generic class called "Box" that holds an object of any type can be declared as follows:

csharp

class Box<T> {
  private T object;
  
  public T getObject() {
    return object;
  }
  
  public void setObject(T object) {
    this.object = object;
  }
}

In this example, T is the type parameter, and it acts as a placeholder for the actual data type that will be used when the Box class is instantiated. To use this class, you can declare a Box object and specify the actual data type between the angle brackets:

php

Box<Integer> integerBox = new Box<>();
integerBox.setObject(123);

** What is public final class in Java?

In Java, a public final class is a class that can be accessed from anywhere in the code and cannot be extended or subclassed. A final class is a class that cannot be subclassed. When a class is declared as public final, it means that it can be accessed from any other class in the code, but cannot be extended or subclassed. This is useful for creating utility classes or for enforcing certain constraints on the implementation of a class.

** What is @Override in Java?

In Java, the @Override annotation is used to indicate that a method is intended to override a method in a superclass. When you annotate a method with @Override, the compiler will check that the method being overridden actually exists in the superclass, and will generate an error if it doesn't. This helps to catch accidental naming errors and makes it easier to see when a method is intended to override a superclass method. The use of the @Override annotation is considered best practice in Java programming, and is widely used by Java developers.

** Could you explain this in Java?

public abstract class Proc {
    protected Proc() {}
}

The code you've posted is a Java class declaration for an abstract class named Proc.

    The class is declared as public, meaning it can be accessed from anywhere in the codebase.
    The class is declared as abstract, meaning it cannot be instantiated on its own and must be extended by a subclass.
    The constructor is declared as protected, meaning it can only be accessed within the same class or a subclass of this class.

In summary, this code declares a public abstract class Proc with a protected constructor, meaning that instances of the class cannot be created directly but only by subclasses that extend the Proc class.

** [[https://senetsy.ru/materials/publications/posts/full-view-or-not-full-view/][Фулвью ор нот фулвью: о пользе и вреде полной BGP-таблицы — SENETSY]]

Фулвью ор нот фулвью: о пользе и вреде полной BGP-таблицы

На любом околосетевом форуме легко найти с десяток веток о выборе оборудования
для BGP-пиринга с возможностью «держать две, три, пять, двадцать пять
фулвью». Большинство таких веток выливается в холивары на тему Cisco
vs. Juniper или еще чего похуже. Офлайновое же их развитие нередко напоминает
мультфильм о шести шапках из одной овичины. В общем, бывает смешно.

И крайне редко обсуждается вопрос о необходимости этого самого фулвью.
Немножко «теории»

Не пугайтесь, я не стану рассказывать все с начала. Уверен, что большинству
читателей хорошо известно содержимое моей теоретической вводной. Желающие
могут смело ее пропустить. Однако же я регулярно сталкиваюсь с некоторой
неуверенностью вполне компетентных в практических вопросах людей, когда речь
заходит о нижеизлагаемом. Так что все-таки давайте немножко синхронизируем
термины, прежде чем обсуждать матчасть.

Все, что впрямую не касается темы интернетной BGP-таблицы, в частности IGP,
MPLS, VRF/VPN и т. п., оставим за скобками.  Роутинг и ричабилити

Фулвью — это практически справочник «Желтые страницы» для всего
интернета. Только именно «Желтые страницы», а не ваша личная записная
книжка. Принципиальная разница тут в том, что помимо разрешения букв в цифры —
для чего в интернете служит не фулвью, а DNS — периодические справочники дают
нам возможность знать о появлении и исчезновении объектов. Нужно же нам как-то
узнавать, что тот или иной адрес вообще есть в интернете. Мало того, если
вдруг он для нас доступен только через линк А, а через Б недоступен — мы ведь
тоже хотим об этом знать. Это и есть сигнализация доступности
(reachability). Не будем слишком глубоко в вдаваться в абстракции, отметим
лишь важность осознавать, что ричабилити и роутинг суть разные вещи.

Роутинг (маршрутизация) — нахождение лучшего пути передачи трафика для
заданного направления. Этот процесс мало похож на поиск в телефонном
справочнике, а скорее имеет отношение к карте города: если один и тот же адрес
x.x.x.x доступен нам и через линк А, и через линк Б, нужно принять решение,
куда же посылать пакеты.

Предположим, что читатель знаком с протоколом IP и в курсе, что такое префикс,
зачем ему длина, и с чем едят правило лонгест мач.

Итак, как видно из показанного выше знаменитого графика c bgp.potaroo.net ,
полная таблица интернет-маршрутизации (здесь и далее речь в основном об IPv4,
хотя почти все кроме цифр справедливо также и для IPv6) нынче содержит почти
350 тысяч записей. Это число растет экспоненциально и довольно быстро. Каждая
из записей представляет собой, собственно, маршрут: IP-префикс назначения
(подсеть с маской), некстхоп (следующий узел aka «куда посылать») и разные там
другие параметры, определяющие ценность этого маршрута. Когда есть два
(полученных от разных маршрутизаторов-соседей) маршрута для одного префикса, в
ход идут как раз эти атрибуты. Они определяют, какой некстхоп будет
использован для передачи.

Здесь показаны три маршрута к префиксу 8.8.8.0/24, полученные от трех разных
маршрутизаторов-соседей. По некоторой причине — кстати, в данном случае
нетривиальной — первый из них был выбран наилучшим (в примере причина не
показана). Пусть вас не смущает и то, что у всех трех маршрутов один и тот же
некстхоп: данные сняты с весьма специфического маршрутизатора, не передающего
транзитный трафик. И да, маршрутизатор-сосед и некстхоп — это не одно и то же.

Анонсируются маршруты между маршрутизаторами при помощи протокола BGP, который
собой являет, ну, практически RSS-трансляцию (да простят меня теоретики за
кощунственное сравнение). Собственно, термин Full View — популярен в основном
у нас, иностранные коллеги чаще говорят Full BGP, Full Table или Full Feed.

То есть сам протокол ничего сложного из себя не представляет — просто способ
автоматизированного обмена данными, обернутыми в лучших программистских
традициях в нечто вроде контейнеров, которые стандарт протокола позволяет
более-менее гибко расширять по мере необходимости. Механизмы поиска наилучшего
пути (роутинга) и контроля связности (ричабилити) у него довольно просты, если
не сказать примитивны. В частности BGP считает, что трафик передается не между
маршрутизаторами, а между укрупненными сущностями: автономными системами (АС,
произносится «а-эс») и почти ничего не знает об их внутренней структуре — путь
через две транзитных АС, каждая из которых включает, скажем, десять внутренних
хопов (маршрутизаторов), BGP сочтет более выгодным, чем путь через пять АС,
каждая из которых внутри имеет два хопа. Кроме того, BGP практически ничего не
знает о пропускной способности линков; в нашем приближении можно считать, что
этот аспект вообще никак не учитывается при выборе маршрута.

По сравнению с другими протоколами он не слишком быстр в обнаружении изменений
связности и, как мы только что убедились, далеко не всегда оптимально ищет
лучшие пути. Однако это все — не только минус, но и плюс BGP, т. к. именно
благодаря своей относительной прямолинейности и «укрупненности мазков»
протокол хорошо приспособлен для передачи большого объема маршрутной
информации.

Так вот таблица в 340 тысяч записей с кучей атрибутов — это довольно много. А
таблиц таких нужно обычно не меньше двух («мэньше нэ былло смы-исла», но об
этом потом). Одно лишь хранение всего этого добра требует многих сотен
мегабайт памяти, а кроме передачи и держания в памяти, таблицы нужно
«обсчитать», в результате чего получить набор наилучших (активных) маршрутов.

Например. Один маршрутизатор-сосед анонсировал нам, что он знает маршрут,
скажем, к Гуглу, и другой сосед — тоже анонсировал. Теперь мы знаем, что Гугл
доступен нам через каждого из соседей (ричабилити) и хотим принять решение,
какой же из двух маршрутов использовать для передачи пакетов (роутинг). Для
этого BGP сравнивает показания (разные атрибуты маршрутов: Local Preference,
AS-PATH и другие) и принимает решение (по каким-то там, не имеющим сейчас
значения критериям), что, допустим, через первого соседа лучше. И так для
каждого префикса. Таким образом из нескольких таблиц (каждая из которых
состоит из 340 тыс. записей), полученных от разных соседей, «компилируется»
одна таблица на 340 тыс. активных маршрутов:

Конструкция из нескольких еще необсчитанных BGP-фидов (если быть точнее, то не
только их, но и данных других протоколов), называется RIB (routing information
base). Хранится она как правило в самой обычной оперативной памяти и
обрабатывается самым обычным процессором. Соответственно именно к этим двум
элементам и предъявляются требования, когда речь идет о количестве полных
BGP-таблиц, которые можно впихнуть в RIB. Общее количество записей тут
определяется как сумма всех полученных от соседей маршрутов: две фулвью —
почти 700 тыс. префиксов, три — за миллион и т. д.

Вывод первый. Грузить фулвью, если у вас только одна сессия с внешним миром —
бессмыслица. Обладание этим массивом информации не даст ничего, кроме нагрузки
на оборудование, т. к. трафик можно передать только одним способом: «Адам, это
Ева, выбирай себе жену». Представьте, что Адам решил бы прежде
проанализировать 340 тысяч параметров Евы — где бы мы теперь были? Из данного
правила есть редкие исключения, однако если вы не знаете, какие именно, то они
— точно не ваш случай.

Памяти под RIB с несколькими фулвью нужно не то чтобы прям очень много, но
сотни мегабайт — единицы гигабайт (в зависимости от количества фулвью,
реализации и массы других аспектов). Процессору подчас тоже приходится не
очень сладко, особенно в реализациях, имеющих BGP-сканер. Например апдаун
сессии, через которую передается полная таблица, на иных платформах может
приводить к стопроцентной загрузке процессора где-нибудь на полчасика.

Однако же понятно, что гигабайты памяти и гигагерцы процессорной частоты давно
перестали быть чем-то особенным. И даже в контексте сетевого оборудования,
производители которого славятся умением продавать обычную, как в компьютере,
DRAM по цене космических летательных аппаратов, делая вид, что 2 ГБ — вершина
прогресса, приведенные цифры не так уж страшно выглядят. Участники упомянутых
в начале топика форумных дискуссий довольно часто приходят именно к такому
выводу. Мол, главное памяти побольше. Это утверждение, в общем, верно, но к
сожалению на нем дело отнюдь не заканчивается.

Давайте посмотрим, что происходит с фулвью дальше. Но прежде еще одно
маленькое, но очень важное замечание.

Маршрутная информация всегда передается навстречу трафику, который
коммутируется на ее основе. То есть на базе фулвью передается исходящий из
вашей АС трафик. Не смотря на всю очевидность этого тезиса, далеко не всегда
практическое его значение осознается в полной мере.  Форвадинг

Дальше эта «скомпилированная» таблица активных маршрутов используется для
передачи трафика. Называется она FIB (forwarding information base), и
количество записей в ней, грубо говоря, равно количеству записей в одной
фулвью (340 тыс.). С ней все гораздо интереснее.

Лирическое отступление. Вообще говоря, Full View (в отличии от Full BGP Feed)
— это как раз FIB. То есть в большинстве случаев правильнее было бы говорить
не «мне нужен маршрутизатор, способный держать три фулвью», а «мне нужен
маршрутизатор, способный держать три пира с фулвью».

И, кстати, подпись по оси ординат на великой и ужасной картинке, приведенной в
начале поста, неправильная. Это не RIB, а FIB. Заголовок на внутренней
странице об этом тоже какбе намекает.

Большинство современных маршрутизаторов, способных передавать трафик на
скоростях от пары гигабит в секунду и выше, — «аппаратные». Аппаратность их в
том, что FIB и ее атрибуты помещается не в обычную, а в специальную, грубо
говоря, «быструю» коммутационную память (SRAM, TCAM, RLDRAM и пр.), к которой
обращаются специальные же процессоры обработки пакетов. Эта память — едва ли
не самый дорогой ресурс в маршрутизаторе. А возможная изощренность работы с
ней — уж точно самый главный из факторов, влияющих на цену железа.

Скажем, коммутатор на 24 гигабитных порта, способный передавать трафик со
страшной силой (одновременно на полной скорости всех интерфейсов), нынче стоит
каких-нибудь пару тысяч долларов или даже еще дешевле. Он тоже вполне
«аппаратный» и скорее всего мощности процессора и объема оперативки в нем
достаточно, чтобы без проблем обмолотить штуки четыре фулвью в RIB. Мало того,
часто софт в нем поддерживает много разных сложных фич. Однако «полноценный
маршрутизатор», способный делать, казалось бы, то же самое, стоит раз в
пятнадцать дороже. Все потому что помимо разного рода маркетологических
тонкостей у коммутатора в таблицу коммутации можно поместить от силы 10–15
тыс. маршрутов, и набор доступных действий с этой таблицей у него значительно
уже. Скажем, если для каждого пакета нужно искать запись в FIB не один раз, а
два или три (это нужно чаще, чем вы думаете) — то коммутаторы за 2 тыс. $
такого не умеют.

Есть также программные коробки (производительностью, грубо говоря, до
гигабита-двух), у которых, соответственно, FIB, как и RIB, хранится в обычной
оперативке. У них, вообще, частенько слишком много всего в ней хранится, но об
этом как-нибудь в другой раз — главное, что она (оперативка) не
резиновая. Мало того, программный поиск по массиву с нахождением наилучшего
соответствия (longest match) — ну очевидно же, что тем медленнее, чем больше в
массиве элементов, каким алгоритмом н Вывод второй.Подбирая аппаратный
маршрутизатор на BGP-пиринг с фулвью, испросите продавца насчет максимального
размера FIB. Если продавец не знает — повод призадуматься о его
компетентности. Возможные варианты: < 500 тыс. для IPv4 — лучше не стоит такое
сегодня брать. Совсем не за горами время, когда этого будет мало. А ведь есть
еще и IPv6.  ~500 тыс. — эта цифра популярна для т. н. больших
L3-коммутаторов, тех самых, у которых дури много, а набор коммутационных
процедур довольно посредственный Хотя бывают приятные исключения. «Большие» от
«маленьких» коммутаторов здесь отличаются во-первых размером коробки и
старшинством модели в линейке, во-вторых и в-главных — объемом коммутационной
памяти: редко когда «маленький» 24-портовый коммутатор поддерживает
полмиллиона записей в FIB. Так вот, хотя коммутационной памяти у «больших»
L3-коммутаторов вроде бы достаточно для сегодняшней фулвью, проделывать с
пакетом сложные штуки они почти никогда не умеют (собственно, в этом их
главное отличие от маршрутизаторов). Их, с одной стороны, если очень хочется,
вроде бы и можно использовать для этой задачи, с другой — лучше бы не
надо. Очень уж там много всяких нюансов. Короче, подумайте и помучайте
продавца хорошенько, прежде чем покупать L3-коммутатор на BGP-пиринг c фулвью.
миллион и больше — достойная цифра.

Если продавец сможет вас более-менее уверенно проконсультировать еще и про
размер RIB — сколько пиров с фулвью вы сможете держать на выбираемом аппарате
— это верный признак продавца, который знает толк в том, чем торгует. Если же
он еще и в состоянии поддержать беседу про отличие больших L3-коммутаторов от
полноценных маршрутизаторов и готов вам рассказать о возможных последствиях
использования больших коммутаторов для BGP-пиринга — вы на правильном пути,
осталось договориться с ним о цене.  Практические рассуждения

Теперь нам предстоит ответить на обозначенный в заголовке вопрос о пользе и
вреде фулвью. Для этого сначала еще чуточку пофилософствуем.  Агрегация
vs. детализация

При динамической передаче маршрутов существует два противоположных принципа
(слово «принцип» здесь означает не «убеждение» или «склонность», а скорее
технический прием, используемый по назначению) работы с маршрутной
информацией: детализация и агрегация. То есть либо подробность: много длинных
префиксов, либо краткость: представление нескольких длинных префиксов в виде
одного покороче.  Агрегация

Вообще говоря, уже ясно, что от детализации много вреда: каждый школьник
знает, что чем больше информации, тем сложнее ее хранить и дороже ею
оперировать. Во времена программных маршрутизаторов и юности IP тезис о
необходимости минимизации количества маршрутов был аксиомой, не подлежащей
обсуждению. Ради борьбы со снижением производительности от распухания RIB и
FIB было придумано очень много всего интересного. К примеру, бесчисленные и
беспощадные типы арий и LSA в OSPF или такая штука как MPLS (да-да, он вовсе
не ради VPN или TE был изобретен), Cisco Express Forwarding и другие разной
степени полезности вещи, включая, собственно, аппаратный форвадинг.

Агрегация (суммаризация) — целая маленькая наука, связанная с грамотным
сегментированием, выбором адресного плана, умением управляться со всякими
IGP-ариями, ловкостью рук при написании правил маршрутизации и
т. п. Интересующихся отсылаю например к книге «Принципы проектирования
корпоративных IP-сетей» А. Ретаны, Д. Слайса и Р. Уайта (Cisco Press).

Экстремальный случай агрегации — маршрут по умолчанию («дефолт»): 0.0.0.0/0,
означающий «все, кроме того, к чему есть явные маршруты».  Детализация

К сожалению, интернет — такая штука, к которой слабо применимо все это
блестящее искусство агрегации. Принципы независимости от географии, отсутствия
централизованного управления, административной изолированности автономных
систем, минимизации области повреждений при отказах и т. д. приводят к тому,
что соседние префиксы, к примеру 212.90.0.0/19 и 212.90.32.0/19, если только
они не принадлежат одной автономной системе (и здесь тоже далеко не всегда это
возможно), никак нельзя представить в виде агрегированного префикса
212.90.0.0/18 с общими параметрами. В общем случае такая суммаризация может
привести к возникновению закольцовок или «черных дыр».

Однако курсивное выделение «в общем случае» — неспроста. Очевидным исключением
является вышеупомянутый маршрут по умолчанию. Собственно именно он
используется как маршрут в интернет (и не только) в случаях, когда никакой
фулвью у нас нету. То есть это практически единственно возможная альтернатива
фулвью: наплевать вообще на всю внутреннюю структуру интернета. Давайте
посмотрим, когда это возможно, и в чем разница форвадинга на базе дефолта и
полной таблицы.  Кому и зачем же нужна фулвью?

С дефолтом все понятно: все, для чего нет специфических (своих) маршрутов,
шлем провайдеру (аплинку) aka в интернет. А что, в сущности, дает нам тут
фулвью? Она дает возможность принимать решения о выборе линка для послыки
пакета, опираясь на знание не обо всем интернете в целом, а об отдельных его
ресурсах. Во-первых пример: маршрут x.x.x.x/x доступен через линки A и Б, а
маршрут y.y.y.y/y — только через линк Б. Раз так, то трафик к y.y.y.y/y можно
посылать только через Б (ричабилити). Во-вторых — мы сможем оказывать влияние
на соответствие между префиксами назначения и соседями, через которых мы будем
слать трафик. Гуглу пошлем трафик через провайдера А, а Яндексу — через Б
(роутинг).

Зачем это может быть нужно?

Первый, неоспоримый случай — наличие как выше- или равностоящих (uplink, IX),
так и нижестоящих (клиенты) АС-соседей. То есть, когда наша автономная система
транзитная, и к ней подключены клиенты, которые тоже что-то нам
анонсируют. Использовать дефолт здесь нельзя по определению, т. к. мы в таком
случае находимся не на окраине, а в «середине» интернета. Наличие агрегации
маршрутов здесь может приводить к закольцовкам. Поэтому провайдерам приходится
держать полную таблицу на всех маршрутизаторах, которые передают
интернет-трафик на основе IP-заголовков. Оговоримся, что варианты «голь на
выдумки хитра» тут тоже возможны, но во-первых их обсуждение выходят за рамки
топика, во-вторых они довольно сложны в эксплуатации при промышленных мастабах
сети. Поэтому, хотя вариации на эту тему не так уж и редко встречаются в
жизни, очень часто их использование в провайдерских автономках привносит
больше проблем, чем пользы.

Вывод третий. Если ваша АС транзитная, то без фулвью скорее всего не
обойтись. Впрочем, вы наверное и сами все это знаете. Про MPLS и BGP-free
core, я думаю, тоже что-нибудь да слышали. Если нет, то это вам ключевые слова
для дальнейшего размышления.  Следующая, более интересная для нас задача —
балансировака нагрузки таким образом, чтобы трафик через интернет шел либо
оптимальными с точки зрения BGP (который, как мы выяснили, не всегда точен в
выборе) путями, либо теми путями, какими мы хотим (и настроим). Оба желания
могут быть вполне законны, если у вас действительно много исходящего (еще раз:
исходящего!) из вашей АС трафика (гигабит-другой и больше), и в сложных
манипуляциях есть экономическая целесообразность. Как правило такое бывает
либо у провайдеров с транзитными автономками, которые все равно попадают под
случай, описанный выше, либо у крупных ЦОДов, у которых, кстати, тоже скорее
всего есть клиенты со своими АС. А даже если нет, то и тут индивидуальное
знание о маршрутах для каждого префикса (которое дает фулвью) не помешает
(см. например байку юзера shapa о его «войне» с Голденом).

Если же ваша АС — не транзитная инфраструктура на продажу, а корпоративная
сеть, пусть даже со своим небольшим (по мировым меркам) ЦОДом, исходящего
трафика у вас скорее всего совсем мало (десятки—сотни мегабит), и задачи типа
посылать трафик к Гуглу одним маршрутом, а к Яндексу другим — у вас почти
наверняка нету (если только любопытства ради). Максимум что вам тут нужно для
исходящего трафика — сбалансировать его либо равномерно, либо в какой-то
нужной пропорции между несколькими интернет-линками. Вопреки бытующему мнению
фулвью для этого не нужна и даже вредна — об этом ниже.

Третий — чуть более интересный и относительно неочевидный случай — фулвью, как
информационное «подспорье». Часто хочется знать, с какими АС у вас идет
наиболее интенсивный обмен трафиком. В ряде случаев, в том числе когда для
передачи трафика фулвью не нужна, хочется снимать статистику для оценки
разного рода тенденций трафика. В этих случаях фулвью используется механизмами
типа NetFlow для получения дополнительной информации о трафике (исходящем и
входящем). Но надо заметить, что реализация подобного мониторинга требует
некоторого опыта и понимания, что должно уметь оборудование, где должна
храниться та фулвью, чем это все чревато, и как правильно интерпретировать
полученную статистику. Короче говоря, это эдвансная тема, выходящая за рамки
топика. Кроме того, если трафика у вас не гигабиты, то скорее всего вам оно и
не нужно. Другой вариант на эту тему — продемонстрированный выше консольный
вывод, снятый со специальных маршрутизаторов, не передающих транзитный
трафик. Они держат фулвью лишь для возможности ее анализа.  Когда можно
обойтись без фулвью?

Крайне распространенным заблуждением является мнение, что, если у вас есть
своя АС и блок адресов, то вы обязаны принимать полную таблицу. Это именно что
заблуждение.

Как было сказано выше, самый сомнительный в отношении нужности фулвью случай
(он же самый массовый и самый богатый неблестящими реализациями) —
корпоративная сеть, которой АС нужна для обладания своим блоком адресов, чтоб,
в свою очередь, не зависеть от провайдеров при резервировании
интернет-ресурсов (публичных серверов, VPN-концентраторов и т. п.) Основная
задача здесь — сделать возможным получение входящего из интернета трафика при
потере одного из внешних подключений. Вспоминаем правило, гласящее, что трафик
передается навстречу маршрутной информации. Вопрос: зачем нам нужна фулвью,
если речь о входящем трафике? Ответ: да ни зачем не нужна.

Хорошо, но если мы отказываемся от фулвью, то как же мы будем передавать
исходящий трафик? Да как обычно! Пишем правило маршрутизации, а еще лучше
договариваемся с провайдером (обычно это не проблема), чтоб не насиловать
оборудование по пустякам (а в идеальном случае для этого придуман механизм
ORF), и принимаем от каждого провайдера только маршрут по умолчанию. Дальше
либо используем только один из маршрутов, а второй держим про запас (на
случай, если первый отвалится) и пускаем весь исходящий трафик по одному
линку, либо настраиваем балансировку нагрузки: равномерную или даже в заданной
пропорции при помощи BGP bandwidth community, если ваше оборудование такое
умеет (вспоминаем разговор про отличие маршрутизаторов от L3-свичей). Все то
же самое, если провайдеров не два, а три, пять, двадцать, сто двадцать.

Некоторый (в общем, единственный) минус такого подхода — это то, что вместе с
«гранулярным» роутингом мы отказались и от контроля над ричабилити: у вас не
будет сигнализации связности с конкретными ресурсами в интернете. Отдельные
префиксы в фулвью — это информация непосредственно от ресурса, которому вам
нужно послать трафик. А дефолт чаще всего сгенерирован вашим провайдером (ну,
или провайдером вашего провайдера, что лучше), и может так случиться, что
дефолт от провайдера вы получаете, а на самом деле никакого интернета у него
(провайдера) нету. Вот вам и иллюстрация «черной дыры» как следствия агрегации
маршрутов.

Во-первых это все-таки не очень большой риск: степень защищенности
инфраструктуры ваших провайдеров в любом случае должна быть на порядок выше,
чем у вас. Если же описанная ситуация происходит часто, то это повод
задуматься о смене провайдера. Во-вторых, при двух интернет-линках и схеме
«основной-резервыный» (напомню, речь только об исходящем трафике), можно
дополнительно подстраховаться: ну, например, получите от основного провайдера
пару префиксов типа Гугла и Яндекса и напишите правило, создающее
агрегированный дефолт только в том случае, если заданные маршруты в норме.

Вы боитесь, что Вконтакте будет доступен только через одного провайдера, а
Одноклассники только через другого? Такой челлендж для вас бизнес-критикал?
Страшно, и желаете защититься? Хотите поговорить об этом с руководством? Оно
тоже так думает и готово потратить деньги? — поздравляю (в первую очередь
вашего поставщика оборудования). Нет? — что ж, для вас чуть ниже будет
заключительный параграф.

В случаях же, когда вам нужна связность не с абстрактным интернетом, а с
конкретными ресурсами, адреса которых (обычно в количестве десятков—сотен)
известны, например, когда речь идет о терминировании статических туннелей для
VPN с филиалами, можно (и даже нужно) кроме дефолта также принять от
провайдеров маршруты к этим ресурсам (удаленным точкам). ORF здесь был бы
особенно актуален, но как-то он не слишком в ходу.  Вред от фулвью

А почему, собственно и не фулвью? Чего париться-то всеми этими рассуждениями?
Ну примем мы его себе, да и все дела?

Во-первых баласировать исходящий трафик в нужной пропорции, когда у вас на
руках фулвью, в разы сложнее и муторнее (совершенно неинтересное занятие). По
умолчанию балансировка работает по принципу «как карта ляжет». Допустим, вы
арендуете широкий канал у провайдера попроще и подешевле и канал поуже у
провайдера покруче и подороже. Так вот, если не принять специальных мер,
бо́льшая часть исходящего трафика у вас попрет в узкий канал и (возможно)
перегрузит его: связность у «крутого» провайдера лучше, и BGP, который
ничегошеньки не знает о пропускной способности ваших линков, будет думать, что
бо́льшая часть интернета к вам «ближе» через узкий канал. Хотя с точки зрения
юзер-экспириенс скорее всего все равно, каким маршрутом слать трафик, главное,
чтобы не было перегрузки. Имея же два дефолта без фулвью и правильный
маршрутизатор, можно и вовсе явно указать пропорцию: в канал поуже слать 30%,
в канал пошире — 70.

Во-вторых по экономическим причинам: корпоративной сети полноценный большой
аппаратный маршрутизатор часто не по карману. Поэтому, если нужна высокая
производительность (гигабиты), можно использовать те самые относительно
дешевые свичи, способные держать в FIB лишь несколько тысяч префиксов.

Однако часто в корпоративных сетях для BGP-пиринга используется менее
производительные, но значительно более многофункциональные программные
коробки. И обычно та же коробка является одновременно бордер-маршрутизатором,
пограничным стейтфул-файрволом, делает нат, всю внутреннюю маршрутизацию, а
иной раз, прости господи, проверяет трафик на вирусы, фильтрует URL, моет
посуду, варит кашу, стирает, гладит и нянчит детей. И все это добро хранится у
нее в оперативной памяти, которая, как я уже отмечал, все-таки не резиновая, и
обрабатывается общим процессором, который тоже не ломовая лошадь. Пихать в
такую коробку еще и несколько фидов с фулвью — совсем как-то ни к чему. Да не
нужно просто этого делать!

Вывод четвертый. Если автономная система у вас не транзитная (вы не провайдер
и у вас нет клиентов со своими АС), и при этом вы сами для себя не можете
четко сформулировать, зачем вам фулвью, — фулвью вам не нужна.  Что, если
очень хочется?

На самом деле у фулвью есть один важный и часто решающий плюс, о котором я до
сих пор стыдливо умалчивал. Многим кажется, что это круто. Одно дело, когда
show route summary показывает 7 маршрутов, и совсем другое — когда 700
тысяч. Какая корпоративная сеть не мечтает стать операторской?  Ответы тут
такие (выбирайте, какой больше нравится): И правильно, не отказывайте себе в
удовольствии. Вендоры и продавцы маршрутизаторов будут очень рады этому вашему
желанию. Надеюсь, работодатель вас в этом тоже поддержит (материально).
Внедряя и администрируя публичную АС и BGP-пиринг, вам придется решить более
сложную и интересную задачу: балансировка входящего трафика и резервирование
линков для него. Вид, в котором ваше адресное пространство видно в интернете
(роутинг) и видно ли (ричабилити), как организовать резервирование, что будет
при нарушении внутренней связности АС, и еще целая куча сложных вопросов ждет
от вас решительных и верных действий. Это вам не фулвью принять.  Наконец,
посмотреть, как выглядит полная таблица, можно и на любом публичном
route-сервере (вам, кстати, придется это сделать, отлаживая свои анонсы).

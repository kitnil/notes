:PROPERTIES:
:ID:       5dc36734-8b61-45c8-aa50-9cc5a05e605f
:END:
#+title: Scheme

Minimalist dialect of the [[id:0da5d4f2-d463-4079-b764-a77d3e800de7][Lisp]].

- [[https://github.com/google/schism][google/schism: A self-hosting Scheme to WebAssembly compiler]]
- [[https://github.com/metaphorm/international-scheme][metaphorm/international-scheme: Translating the Scheme programming language to every human language.]]
- [[https://github.com/srfi-explorations/srfi-test][srfi-explorations/srfi-test: Collecting up-to-date test suites for SRFIs]]
- [[https://github.com/srfi-explorations/emacs-srfi/tree/0820be47f39bd63ece2e5b13b1e4a2df49fe663b][srfi-explorations/emacs-srfi at 0820be47f39bd63ece2e5b13b1e4a2df49fe663b]]
- [[https://www.altlinux.org/Scheme][Scheme â€” ALT Linux Wiki]]
- [[http://mumble.net/%257Ecampbell/scheme/style.txt][Riastradh's Lisp Style Rules]]
- http://library.readscheme.org
- https://www.greghendershott.com/fear-of-macros/Transform_.html
- [[https://ecraven.github.io/r7rs-benchmarks/][ecraven.github.io/r7rs-benchmarks/]]
- [[https://call-with.cc/][call-with.cc]]

* Operating system
- [[https://github.com/siraben/zkeme80][siraben/zkeme80: An assembler and operating system for the TI-84+ written in Scheme, Forth and Z80 assembly.]]

* Implementations
- [[https://www-sop.inria.fr/indes/fp/Bigloo/][Bigloo]]
** Learning
- [[https://github.com/TFKls/Heath][TFKls/Heath: A simple scheme-like language.]]
- [[https://github.com/fluentpython/lispy][fluentpython/lispy: Learning with Peter Norvig's lis.py interpreter]]
- [[https://beautifulracket.com/explainer/continuations.html][Beautiful Racket: Continuations]]
- [[https://exercism.org/tracks/scheme][Scheme on Exercism]]
- [[https://www.erichgrunewald.com/posts/using-scheme-to-find-the-median-of-two-sorted-integer-lists/][Using Scheme to Find the Median of Two Sorted Integer Lists]]
- [[https://standards.scheme.org/unofficial/errata-corrected-r7rs.pdf][errata-corrected-r7rs.pdf]]
- [[https://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-2.html#%_toc_start][Revised^5 Report on the Algorithmic Language Scheme]]
** Videos
- [[https://www.twitch.tv/videos/1011771746][(1) Nada Amin's keynote "Staged Relational Interpreters: Running Backwards, Faster" - Twitch]]

* Programs

- [[https://github.com/ebzzry/usync][ebzzry/usync: A simple site-to-site synchronization tool]]

* Misc
- [[https://github.com/kristineorten/sorting-in-scheme][kristineorten/sorting-in-scheme: Implementing sorting algorithms in Scheme]]

* Libraries
- [[https://github.com/etaoins/llambda][etaoins/llambda: Scheme R7RS frontend for LLVM]]

* Snippets

#+BEGIN_SRC scheme
  (use-modules (srfi srfi-9))
  (define-record-type <foo>
    (make-foo x)
    foo?
    (x foo-x))
#+END_SRC
#+begin_example
  scheme@(guile-user)> ,expand (foo-x bar)
  $2 = (let ((s bar))
    (if ((@@ (srfi srfi-9) eq?)
         ((@@ (srfi srfi-9) struct-vtable) s)
         <foo>)
      ((@@ (srfi srfi-9) struct-ref) s 0)
      (let ((s* s))
        ((@@ (srfi srfi-9) throw)
         'wrong-type-arg
         'foo-x
         "Wrong type argument: ~S"
         ((@@ (srfi srfi-9) list) s*)
         ((@@ (srfi srfi-9) list) s*)))))
#+end_example

#+begin_src scheme
  (define (change e1 e2 lst)
    (cond ((null? lst) '())
          ((eq? e1 (car lst)) (cons e2 (change e1 e2 (cdr lst))))
          (else (cons (car lst) (change e1 e2 (cdr lst))))))

  ;; This function basically changes every element that is equal to e1 to e2 in
  ;; a list.
  ;;
  ;; > (change 1 999 '(1 2 1 3 1 4 1 5 1))
  ;; (999 2 999 3 999 4 999 5 999)
#+end_src

* call/cc

Like return from function:
#+BEGIN_SRC scheme
  (let ((my-val (call/cc (lambda (the-continuation)
                           (display "This will be executed\n")
                           (the-continuation 5)
                           (display "This will not be executed\n")))))
    (display my-val))
#+END_SRC

* SRFI

- [[https://srfi.schemers.org/srfi-166/srfi-166.html][SRFI 166: Monadic Formatting]]
